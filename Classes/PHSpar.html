<!doctype html><html lang='en'><head><title>PHSpar | SuperCollider 3.11.0 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'PHSpar';
var scdoc_sc_version = '3.11.0';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>PHSpar:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc2'><a href='#Inherited%20class%20methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-newPaused'>newPaused</a> </li>
<li class='toc3'><a href='#-asTask'>asTask</a> </li>
<li class='toc2'><a href='#Inherited%20instance%20methods'>Inherited instance methods</a></li>
</ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Classes (extension)</span>
 | <span id='categories'><a href='./../Browse.html#Libraries'>Libraries</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>miSCellaneous'>miSCellaneous</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>miSCellaneous>HS and HSpar'>HS and HSpar</a> | <a href='./../Browse.html#Streams-Patterns-Events'>Streams-Patterns-Events</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Streams-Patterns-Events>HS and HSpar'>HS and HSpar</a></span>
</div><h1>PHSpar<span id='superclasses'> : <a href="../Classes/PHelpSynthPar.html">PHelpSynthPar</a> : <a href="../Classes/PHelpSynthParUse.html">PHelpSynthParUse</a> : <a href="../Classes/PHelpSynthUse.html">PHelpSynthUse</a> : <a href="../Classes/Object.html">Object</a></span>
<div class='extension-indicator-ctr' title='This help file originates from a third-party quark or plugin for SuperCollider.'><img class='extension-indicator-icon' alt='Extension' src='./../images/plugin.png'><span class='extension-indicator-text'>Extension</span></div></h1>
<div id='summary'>defines Pbind(s) for using synth values of a HSpar</div>
</div>
<div class='subheader'>
<div id='filename'>Source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/Classes/HS/PHelpSynthPar.sc' title='/home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/Classes/HS/PHelpSynthPar.sc'>PHelpSynthPar.sc</a></div><div id='related'>See also: <a href="./../Overviews/miSCellaneous.html">miSCellaneous</a>, <a href="./../Guides/Guide_to_HS_and_HSpar.html">Guide to HS and HSpar</a>, <a href="./../Tutorials/HS_with_VarGui.html">HS with VarGui</a>, <a href="./../Classes/HSpar.html">HSpar</a>, <a href="./../Classes/PHSparUse.html">PHSparUse</a>, <a href="./../Classes/PHSparPlayer.html">PHSparPlayer</a>, <a href="./../Classes/PHSusePlayer.html">PHSusePlayer</a></div>
</div>
<h2><a class='anchor' name='description'>Description</a></h2>

<p>Defines Pbind(s) which, when played, can use values of synths derived from <a href="./../Classes/HSpar.html">HSpar</a>'s synth definitions.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>PHSpar.</span><a class='method-name' name='*new' href='./../Overviews/Methods.html#new'>new</a>(<span class='argstr'>helpSynthPar</span>, <span class='argstr'>switchDur: 10000</span>, <span class='argstr'>switchIndex: 0</span>, <span class='argstr'>helpSynthArgs</span>, <span class='argstr'>pbindArgs</span>, <span class='argstr'>hsIndices</span>, <span class='argstr'>switchOn: false</span>, <span class='argstr'>switchOff: false</span>, <span class='argstr'>set: true</span>, <span class='argstr'>hsStartIndices: 'all'</span>)</h3>
<div class='supmethod'>From superclass: <a href='./../Classes/PHelpSynthPar.html'>PHelpSynthPar</a></div>
<div class='method'>
<p>Creates a new PHSpar object.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>helpSynthPar<td class='argumentdesc'>
<p>A HSpar object.<tr><td class='argumentname'>switchDur<td class='argumentdesc'>
<p>Duration value or pattern / stream of durations determining the times of HSpar synth switches. <tr><td class='argumentname'>switchIndex<td class='argumentdesc'>
<p>Index or pattern / stream of indices determining HSpar's synth definition to switch to.  Defaults to 0.<tr><td class='argumentname'>helpSynthArgs<td class='argumentdesc'>
<p>Collection of Pbind pair collections (size = number of <strong>helpSynthPar</strong>'s help synths),  defining synth args to be set at switch times.<tr><td class='argumentname'>pbindArgs<td class='argumentdesc'>
<p>Collection of the form <strong>[ dur1, pbindData1, ... , durN, pbindDataN</strong> <strong>]</strong>, whereby <strong>dur</strong> is a duration value or pattern / stream of durations for the corresponding Pbind(s) and <strong>pbindData</strong> is a collection of Pbind pairs or a collection of Pbind pair collections,  defining possibly several Pbinds with same event timing. <tr><td class='argumentname'>hsIndices<td class='argumentdesc'>
<p>Per default values are taken from the currently switched help synth.  Explicitely given <strong>hsIndices</strong> allow reference to values of other help synths from the  corresponding Pbind(s). See the examples below. Expects a collection of valid hsIndex values resp. patterns / streams of valid hsIndex values. A valid hsIndex value is a valid help synth index or a collection of valid help synth indices. The collection's size must equal <strong>N</strong>, the number of <strong>pbindArgs</strong>'s event timings.<tr><td class='argumentname'>switchOn<td class='argumentdesc'>
<p>Boolean or Pattern / Stream of Booleans, determining if switched help synths should be resumed.  Defaults to false.<tr><td class='argumentname'>switchOff<td class='argumentdesc'>
<p>Boolean or Pattern / Stream of Booleans, determining if help synths,  which are left at a switch, should be paused.  Defaults to false.<tr><td class='argumentname'>set<td class='argumentdesc'>
<p>Boolean or Pattern / Stream of Booleans, determining if next synth input values, defined in <strong>helpSynthArgs</strong>, should be  taken for setting the synth. The first help synth args are always set. Defaults to true.<tr><td class='argumentname'>hsStartIndices<td class='argumentdesc'>
<p>A valid help synth index, a collection of valid help synth indices or one of the symbols: \all, \none.  Determines which help synths should be started at the beginning in addition to the one of the first switch index.  Help synths of other than first switch index are played with default args. </table></div><h3><a class='anchor' name='Inherited%20class%20methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-newPaused' href='./../Overviews/Methods.html#newPaused'>newPaused</a>(<span class='argstr'>args</span>, <span class='argstr'>latency</span>)</h3>
<div class='supmethod'>From superclass: <a href='./../Classes/PHelpSynthPar.html'>PHelpSynthPar</a></div>
<div class='method'>
<p>VarGui support, see <a href="./../Tutorials/HS_with_VarGui.html">HS with VarGui</a> for examples.
<p>Return a collection of new paused Synth(s) derived from HSpar's ugenFunc definition(s), which may be passed to a VarGui object.  VarGui will automatically detect the origin from a HSpar definition and gui functionality wil be adapted.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>args<td class='argumentdesc'>
<p>Collection of collection(s) of key / value pairs for the HSpar synth(s).<tr><td class='argumentname'>latency<td class='argumentdesc'>
<p>SimpleNumber (seconds). </table></div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asTask' href='./../Overviews/Methods.html#asTask'>asTask</a>(<span class='argstr'>clock</span>, <span class='argstr'>quant</span>, <span class='argstr'>hsStop: false</span>, <span class='argstr'>hsPlay: true</span>, <span class='argstr'>switchStop: false</span>, <span class='argstr'>newEnvir: true</span>, <span class='argstr'>removeCtrWithCmdPeriod: true</span>)</h3>
<div class='supmethod'>From superclass: <a href='./../Classes/PHelpSynthPar.html'>PHelpSynthPar</a></div>
<div class='method'>
<p>VarGui support, see <a href="./../Tutorials/HS_with_VarGui.html">HS with VarGui</a> for examples.
<p>Returns a wrapper Task, which may be passed to a VarGui object.  Playing and stopping the wrapper Task invokes playing and  stopping behaviour of the underlying PHSparPlayer, per default also taking control over  playing and stopping the help synth(s). <h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>clock<td class='argumentdesc'>
<p>TempoClock.<tr><td class='argumentname'>quant<td class='argumentdesc'>
<p>Quant or SimpleNumber.<tr><td class='argumentname'>hsStop<td class='argumentdesc'>
<p>Boolean, Integer or SequenceableCollection of Integers determining help synth indices.  Determines if help synth(s) will stop together with PHSparPlayer. Defaults to false.<tr><td class='argumentname'>hsPlay<td class='argumentdesc'>
<p>Boolean, Integer or SequenceableCollection of Integers determining help synth indices. Determines if help synth(s) will resume together with PHSparPlayer. Defaults to true.<tr><td class='argumentname'>switchStop<td class='argumentdesc'>
<p>Boolean. Determines if switching will stop together with PHSparPlayer. Defaults to true.<tr><td class='argumentname'>newEnvir<td class='argumentdesc'>
<p>Boolean. Determines if Task will be played in a newly generated environment. Defaults to true. This option especially becomes important when PHSpar's <strong>pbindData</strong> contains functional code with  environmental variables.<tr><td class='argumentname'>removeCtrWithCmdPeriod<td class='argumentdesc'>
<p>Boolean. Defaults to true.  Determines if notification of PHSparPlayer will be stopped with CmdPeriod.</table></div><h3><a class='anchor' name='Inherited%20instance%20methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h2><a class='anchor' name='examples'>Examples</a></h2>
<textarea class='editor'>(
s = Server.local;
Server.default = s;
s.boot;
)

// define a HSpar with two help synth definitions 

(
h = HSpar(s, [ 
    { |freq = 1, dev = 5, center = 65|
        LFDNoise3.kr(freq, dev, center) },
    { |freq = 1, dev = 5, center = 75, addFreq = 0.1, addDev = 5|
        LFTri.kr(freq, 0, dev, center) + SinOsc.kr(addFreq, 0, addDev) } 
]);
)

// define a PHSpar to switch between these two
// reference to currently switched help synth via ~val
// note that pbindArgs, different from PHS, have to be given as collection

(
p = PHSpar(h, 
    3, // switch duration
    Pseq([0,1],inf), // switch indices
    // center of help synth #0 is reset at every switch, default values for help synth #1 :
    [ [\center, Pseq([65, 90], inf)], nil], 
    // ~val refers to current switch :
    [0.1, [\midinote, Pkey(\val) + Pseq([0,1],inf), \legato, 0.2 ] ]
).play;  
)

// stop and free HSpar

p.free;



// no need to define a switch pattern 
// default switch index = 0, default switch duration = inf
// hsIndices value \all causes that all help synth values at 
// corresponding Pbind times are accesible via ~vals

(
p = PHSpar(h, 
    pbindArgs: [0.1, [\midinote, Pkey(\vals) /* collection, thus played as interval */ + Pseq([0,1],inf), 
        \legato, 0.2 ] ],
    hsIndices: [ \all ] 
).play;  
)

p.free;



// this is a bit wasteful as always both help synth values are demanded via the OSCresponder mechanism:
// see printed (serverToClient) OSC traffic

(
h.postOSC = true;

p = PHSpar(h, 
    pbindArgs: [0.1, [\midinote, Pkey(\vals).collect(_.at(1)) /* take only the second */ + 
        Pseq([0,1],inf), \legato, 0.2 ] ],
    hsIndices: [ \all ] 
).play;  
)

p.free;



// the index may be determined by hsIndices 
// only the needed help synth value is demanded and can be referenced via ~thisVal:
// compare printed OSC traffic 

(
p = PHSpar(h, 
    pbindArgs: [0.1, [\midinote, Pkey(\thisVal) /* take value determined by hsIndices */ + 
        Pseq([0,1],inf), \legato, 0.2 ] ],
    hsIndices: [ 1 ] 
).play;  
)

(
p.free;
h.postOSC = false;
)


// hsIndices may contain patterns
// only the needed help synth value is demanded and can be referenced via ~thisVal (or ~theseVals) :

(
p = PHSpar(h, 
    pbindArgs: [0.1, [\midinote, Pkey(\thisVal) + Pseq([0,1],inf), \legato, 0.2 ] ],
    hsIndices: [ Prand([0,1], inf) ] 
).play;  
)

p.free;



// hsIndices also accepts collections of indices or patterns thereof, 
// referenced by ~theseVals (which is always a collection)

(
p = PHSpar(h, 
    pbindArgs: [0.1, [\midinote, Pkey(\theseVals) + Pseq([0,1],inf), \legato, 0.2 ] ],
    hsIndices: [ Pstutter(Pwhite(5,10), Pxrand([0, 1, [0,1]], inf)) ] 
).play;  
)

p.free;



// two Pbinds with different event timing
// hsIndices specified for each

(
p = PHSpar(h, 
    // "+" wraps collections, so if ~theseVals is an interval then 
    // ~midinote consists of the two added sevenths [-5, 5], [0, 10], 
    // otherwise ~midinote is a chord of fourths
    pbindArgs: [0.2, [\midinote, Pkey(\theseVals) + [-5, 0, 5,10] , \legato, 0.2, \amp, 0.05 ],
        0.1, [\midinote, Pkey(\thisVal) + Pseq([0,1],inf), \legato, 0.2, \amp, 0.08 ]],
    hsIndices: [ Pstutter(Pwhite(5,10), Pxrand([0, 1, [0,1]], inf)), 0]
).play;  
)

p.free;



// the switched indices can be referenced via the hsIndices arg by symbol \switch
// \all is synonym to [0,1] in the last example

(
p = PHSpar(h,
    Pwhite(0.5, 1.5),// switch duration
    Pseq([0,1],inf), // switch indices
    [ [], [] ], // default values for help synths
    // "+" wraps collections, so if ~theseVals is an interval then
    // ~midinote consists of the two added sevenths [-5, 5], [0, 10], 
    // otherwise ~midinote is a chord of fourths 
    [ 0.2, [\midinote, Pkey(\theseVals) + [-5, 0, 5,10] , \legato, 0.2, \amp, 0.05 ],
      0.1, [\midinote, Pkey(\thisVal) + Pseq([0,1],inf), \legato, 0.2, \amp, 0.08 ] ],
    [ Pstutter(Pwhite(5,10), Pxrand([0, 1, \all], inf)), \switch ]
    // single line switches between trill and arpeggio 
).play;  
)

p.free;


//////////////////////////////////////////////////////////////////////////////////


// HSpar with two help synth definitions

(
h = HSpar(s, [ 
    { |start = 90, end = 60, dur = 10, add = 0|
        XLine.kr(start, end, dur) + add; },
    { |freq = 0.3, dev = 15, center = 60, phase = 0, add = 0|
        LFTri.kr(freq, phase, dev, center + add); }
]);
)


// switch between two help synths
// both help synths are run from the start (default hsStartIndices = true)
// help synths of switch index are paused when index is left (switchOff: true) and 
// resumed when index is given (switchOn: true)
// movement downwards needs more than 10 seconds defined by XLine

(
p = PHSpar(h, 
    Pwhite(0.3,1.0), // switch duration
    Pseq([0,1], inf), // switch indices,
    // distinguish help synth values by reference to ~switchIndex
    pbindArgs: [0.12, [\midinote, Pkey(\val) + 
        Pkey(\switchIndex).collect(switch(_, 0, [0,2.5], 1, [0,7])), \legato, 0.2 ] ],
    switchOn: true,
    switchOff: true
).play;  
)

p.free;



// never pause help synth #0, always pause #1
// end value of help synth #0 reached after 10 seconds

(
p = PHSpar(h, 
    Pwhite(0.3,1.0), // switch duration
    Pseq([0,1], inf), // switch indices,
    // distinguish help synth values by reference to ~switchIndex
    pbindArgs: [0.12, [\midinote, Pkey(\val) + 
        Pkey(\switchIndex).collect(switch(_, 0, [0,2.5], 1, [0,7])), \legato, 0.2 ] ],
    switchOn: true,
    switchOff: Pseq([false, true], inf) // next pause value with next switch index
).play;  
)

p.free;



// hsStartIndices: define which help synths should be run from the beginning (only #1)
// help synth #0 is run when switched first (switchOn: true) 
// movement downwards starts after 5 seconds

(
p = PHSpar(h, 
    Pseq([5, Pwhite(0.3,1.0, inf)]), // switch duration
    Pseq([1,0], inf), // switch indices,
    // distinguish help synth values by reference to ~switchIndex
    pbindArgs: [0.12, [\midinote, Pkey(\val) + 
        Pkey(\switchIndex).collect(switch(_, 0, [0,2.5], 1, [0,7])), \legato, 0.2 ] ],
    switchOn: true,
    hsStartIndices: 1 // \none (except the switched) or [1] would also do
).play;  
)

p.free;



// set: determines whether new values should be polled from 
// streams (defined in helpSynthArgs) at switch time.
// Here only at every second switch a new add value (register change) is set.

(
p = PHSpar(h, 
    Pwhite(0.3, 0.5, inf), // switch duration
    Pseq([0,1], inf), // switch indices,
    [ [\add, Pseq([0, 10.5, 21], inf) ], [\add, Pseq([0, 10.5, 21], inf), \dev, 5] ],  // helpSynthArgs
    // distinguish help synth values by reference to ~switchIndex
    pbindArgs: [0.12, [\midinote, Pkey(\val) + 
        Pkey(\switchIndex).collect(switch(_, 0, [0,2.5], 1, [0,7])), \legato, 0.2 ] ],
    set: Pstutter(2, Pseq([true, false], inf))  // next set value with next switch index
).play;  
)

p.free;



// now things quite mixed up

// basic pitches chosen by index sequence defined in hsIndices, reference by Pkey(\theseVals)
// switchIndex only determines the added interval
// if theseVals contains only one value the determined interval is based on this value 
// ([a] + [x, y] = [a + x, a + y]), 
// otherwise it is just added to the interval of theseVals 
// ([a, b] + [x, y] = [a + x, b + y])  

// printout of variables which may be used within a PHSpar definition
// timeGrains is just a time ID, depending on granularity, not used for scheduling

(
p = PHSpar(h, 
    Pwhite(0.3,1.0), // switch duration
    Pseq([0,1], inf), // switch indices,
    // distinguish added interval by reference to ~switchIndex
    pbindArgs: [0.12, [
        \midinote, Pkey(\theseVals) + Pkey(\switchIndex).collect(switch(_, 0, [0, 2.5], 1, [0, 7])), 
        \legato, 0.2,
        \post, Pfunc {|e| e.use {
            "demandIndex: ".post; ~demandIndex.postln;
            "timeGrains: ".post; ~timeGrains.postln;
            "dur: ".post; ~dur.postln;
            "switchIndex: ".post; ~switchIndex.postln;
            "vals: ".post; ~vals.postln;
            "val: ".post; ~val.postln;
            "theseIndices: ".post; ~theseIndices.postln;
            "theseVals: ".post; ~theseVals.postln;
            "thisVal: ".post; ~thisVal.postln;
            "================================".postln;
            }
        }
    ]],
    hsIndices: [ Pstutter(Pwhite(5,10), Pxrand([ 0, 1, \all ], inf)) ]
).play;  
)

p.free;</textarea>

<p><div class='doclink'>helpfile source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Classes/PHSpar.schelp'>/home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Classes/PHSpar.schelp</a><br>link::Classes/PHSpar::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>