<html><head><title>ProcModR</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES (extension)</div>
<div id='categories'><a href='./../Browse.html#Libraries>JoshUGens'>Libraries>JoshUGens</a></div>
<h1>ProcModR</h1>
<div id='summary'>An extension to the ProcMod real-time control structure</div>
</div>
<div class='subheader'>
<div id='filename'>Source: <a href='file:///usr/local/share/SuperCollider/Extensions/SC3plugins/JoshUGens/classes/ProcMod.sc'>/usr/local/share/SuperCollider/Extensions/SC3plugins/JoshUGens/classes/ProcMod.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/ProcMod.html">ProcMod</a> : <a href="../Classes/Object.html">Object</a></div>
<div id='related'>See also: <a href="./../Classes/ProcMod.html">ProcMod</a>, <a href="./../Classes/ProcEvents.html">ProcEvents</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*play'>play</a> </li>
<li class='toc3'><a href='#*initClass'>initClass</a> </li>
<li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-setupRouting'>setupRouting</a> </li>
<li class='toc3'><a href='#-clear'>clear</a> </li>
<li class='toc3'><a href='#-initProcModR'>initProcModR</a> </li>
<li class='toc3'><a href='#-play'>play</a> </li>
<li class='toc3'><a href='#-now'>now</a> </li>
<li class='toc3'><a href='#-routebus'>routebus</a> </li>
<li class='toc3'><a href='#-headerFormat'>headerFormat</a> </li>
<li class='toc3'><a href='#-release'>release</a> </li>
<li class='toc3'><a href='#-notegroup'>notegroup</a> </li>
<li class='toc3'><a href='#-processor'>processor</a> </li>
<li class='toc3'><a href='#-kill'>kill</a> </li>
<li class='toc3'><a href='#-sampleFormat'>sampleFormat</a> </li>
<li class='toc3'><a href='#-numChannels'>numChannels</a> </li>
<li class='toc3'><a href='#-recordPM'>recordPM</a> </li>
<li class='toc3'><a href='#-isRecording'>isRecording</a> </li>
<li class='toc3'><a href='#-procout'>procout</a> </li>
<li class='toc3'><a href='#-hdr'>hdr</a> </li>
<li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
</ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>A structure for controlling modular processes, with the capabilitiy to record its output in real-time.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*play' href='./../Overviews/Methods.html#play'>play</a> (<span class='argstr'>env</span>, <span class='argstr'>amp: 1</span>, <span class='argstr'>numChannels: 0</span>, <span class='argstr'>procout: 0</span>, <span class='argstr'>id</span>, <span class='argstr'>group</span>, <span class='argstr'>addAction: 0</span>, <span class='argstr'>target: 1</span>, <span class='argstr'>function</span>, <span class='argstr'>releaseFunc</span>, <span class='argstr'>onReleaseFunc</span>, <span class='argstr'>responder</span>, <span class='argstr'>timeScale: 1</span>, <span class='argstr'>lag: 0.01</span>, <span class='argstr'>clock</span>, <span class='argstr'>server</span>, <span class='argstr'>recpath</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>env<td class='argumentdesc'>
<p>An overall amplitude envelope that synths created and sent to the ProcModRs internal routing bus will be shaped by. There is a max of 20 breakpoints to the env. If the Env has a releaseNode, ProcModR will continue to process events until .release is called.<tr><td class='argumentname'>amp<td class='argumentdesc'>
<p>An overall amplitude control for an instance of ProcMod.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels of output events in this function will contain.<tr><td class='argumentname'>procout<td class='argumentdesc'>
<p>Where the sound from this ProcModR should be routed to.<tr><td class='argumentname'>id<td class='argumentdesc'>
<p>A \symbol or "string" to be used later to identify an instance of ProcMod.<tr><td class='argumentname'>group<td class='argumentdesc'>
<p>A group for an instance of ProcMod to run in. Defaults to nil and a new group is created. If ProcMod creates the group, a new one is created on each .play call.<tr><td class='argumentname'>addAction<td class='argumentdesc'>
<p>An addAction for this instance of ProcMod. Defaults to 0.<tr><td class='argumentname'>target<td class='argumentdesc'>
<p>A target for this instance of ProcMod. Defaults to 1.<tr><td class='argumentname'>function<td class='argumentdesc'>
<p>A Function, Task or Routine to be evaluated on the playing of this instance of ProcMod. If a Function is passed in that returns a Task or Routine, the ProcMod will become 're-triggerable' and will allow for overlapping getures (it can be released and restarted immediately). All Functions, when evaluated, will have the current group id and envbus passed in as an argument.<tr><td class='argumentname'>releaseFunc<td class='argumentdesc'>
<p>A Function, Task or Routine to be evaluated after the ProcMod has finished its release.<tr><td class='argumentname'>onReleaseFunc<td class='argumentdesc'>
<p>A Function, Task or Routine to be evaluated at release time.<tr><td class='argumentname'>responder<td class='argumentdesc'>
<p>An instance of OSCresponder or OSCresponderNode for use by this instance of ProcMod. It is automatically added when the ProcMod starts, and released after the ProcMod finishes its release.<tr><td class='argumentname'>timeScale<td class='argumentdesc'>
<p>Applies a scale function to the ProcMod envelope. Defaults to 1.<tr><td class='argumentname'>lag<td class='argumentdesc'>
<p>Applies to chages to the amp value passed into this instance of ProcMod.<tr><td class='argumentname'>clock<td class='argumentdesc'>
<p>An intance of Clock to run this instance of ProcMod. Defaults to SystemClock.<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>An instance of Server to run this ProcMod on. Useful for remote servers. Defaults to Server.default.<tr><td class='argumentname'>recpath<td class='argumentdesc'></table></div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*initClass' href='./../Overviews/Methods.html#initClass'>initClass</a> </h3>
<div class='method'></div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./../Overviews/Methods.html#new'>new</a> (<span class='argstr'>env</span>, <span class='argstr'>amp: 1</span>, <span class='argstr'>numChannels: 0</span>, <span class='argstr'>procout: 0</span>, <span class='argstr'>id</span>, <span class='argstr'>group</span>, <span class='argstr'>addAction: 0</span>, <span class='argstr'>target: 1</span>, <span class='argstr'>function</span>, <span class='argstr'>releaseFunc</span>, <span class='argstr'>onReleaseFunc</span>, <span class='argstr'>responder</span>, <span class='argstr'>timeScale: 1</span>, <span class='argstr'>lag: 0.01</span>, <span class='argstr'>clock</span>, <span class='argstr'>server</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>env<td class='argumentdesc'><tr><td class='argumentname'>amp<td class='argumentdesc'><tr><td class='argumentname'>numChannels<td class='argumentdesc'><tr><td class='argumentname'>procout<td class='argumentdesc'><tr><td class='argumentname'>id<td class='argumentdesc'><tr><td class='argumentname'>group<td class='argumentdesc'><tr><td class='argumentname'>addAction<td class='argumentdesc'><tr><td class='argumentname'>target<td class='argumentdesc'><tr><td class='argumentname'>function<td class='argumentdesc'><tr><td class='argumentname'>releaseFunc<td class='argumentdesc'><tr><td class='argumentname'>onReleaseFunc<td class='argumentdesc'><tr><td class='argumentname'>responder<td class='argumentdesc'><tr><td class='argumentname'>timeScale<td class='argumentdesc'><tr><td class='argumentname'>lag<td class='argumentdesc'><tr><td class='argumentname'>clock<td class='argumentdesc'><tr><td class='argumentname'>server<td class='argumentdesc'></table></div><h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-setupRouting' href='./../Overviews/Methods.html#setupRouting'>setupRouting</a> (<span class='argstr'>argNumChannels</span>, <span class='argstr'>argProcout</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argNumChannels<td class='argumentdesc'><tr><td class='argumentname'>argProcout<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-clear' href='./../Overviews/Methods.html#clear'>clear</a> (<span class='argstr'>oldproc</span>, <span class='argstr'>oldresp</span>, <span class='argstr'>oldgroup</span>, <span class='argstr'>oldrelfunc</span>, <span class='argstr'>oldclock</span>, <span class='argstr'>oldhdr</span>, <span class='argstr'>oldroute</span>, <span class='argstr'>oldccctrl</span>, <span class='argstr'>oldAmpDef</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>oldproc<td class='argumentdesc'><tr><td class='argumentname'>oldresp<td class='argumentdesc'><tr><td class='argumentname'>oldgroup<td class='argumentdesc'><tr><td class='argumentname'>oldrelfunc<td class='argumentdesc'><tr><td class='argumentname'>oldclock<td class='argumentdesc'><tr><td class='argumentname'>oldhdr<td class='argumentdesc'><tr><td class='argumentname'>oldroute<td class='argumentdesc'><tr><td class='argumentname'>oldccctrl<td class='argumentdesc'><tr><td class='argumentname'>oldAmpDef<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-initProcModR' href='./../Overviews/Methods.html#initProcModR'>initProcModR</a> (<span class='argstr'>argClock</span>, <span class='argstr'>argServer</span>, <span class='argstr'>argEnv</span>, <span class='argstr'>argNumChannels</span>, <span class='argstr'>argProcout</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argClock<td class='argumentdesc'><tr><td class='argumentname'>argServer<td class='argumentdesc'><tr><td class='argumentname'>argEnv<td class='argumentdesc'><tr><td class='argumentname'>argNumChannels<td class='argumentdesc'><tr><td class='argumentname'>argProcout<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-play' href='./../Overviews/Methods.html#play'>play</a> (<span class='argstr'>recpath</span>, <span class='argstr'>timestamp: true</span>, <span class='argstr'>argHeaderFormat</span>, <span class='argstr'>argSampleFormat</span>)</h3>
<div class='method'>
<p>Evaluates this instance of ProcMod. ProcMod.function is evaluated, and ProcMod.responder is set up if they are declared.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>recpath<td class='argumentdesc'><tr><td class='argumentname'>timestamp<td class='argumentdesc'><tr><td class='argumentname'>argHeaderFormat<td class='argumentdesc'><tr><td class='argumentname'>argSampleFormat<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-now' href='./../Overviews/Methods.html#now'>now</a> </h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-routebus' href='./../Overviews/Methods.html#routebus'>routebus</a> </h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-headerFormat' href='./../Overviews/Methods.html#headerFormat'>headerFormat</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-headerFormat' href='./../Overviews/Methods.html#headerFormat'>headerFormat</a> = value</h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-release' href='./../Overviews/Methods.html#release'>release</a> (<span class='argstr'>reltime</span>)</h3>
<div class='method'>
<p>Releases an instance of ProcMod. If ProcMod.env has a release section, functions and OSCresponders wait until this has executed before releasing the ProcMods functionality.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>reltime<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-notegroup' href='./../Overviews/Methods.html#notegroup'>notegroup</a> </h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-processor' href='./../Overviews/Methods.html#processor'>processor</a> </h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-kill' href='./../Overviews/Methods.html#kill'>kill</a> </h3>
<div class='method'>
<p>Immediately free the ProcMod, regardless of ProcMod.env.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sampleFormat' href='./../Overviews/Methods.html#sampleFormat'>sampleFormat</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-sampleFormat' href='./../Overviews/Methods.html#sampleFormat'>sampleFormat</a> = value</h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-numChannels' href='./../Overviews/Methods.html#numChannels'>numChannels</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-numChannels' href='./../Overviews/Methods.html#numChannels'>numChannels</a> = <span class='argstr'>num</span></h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>num<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-recordPM' href='./../Overviews/Methods.html#recordPM'>recordPM</a> (<span class='argstr'>path</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-isRecording' href='./../Overviews/Methods.html#isRecording'>isRecording</a> </h3>
<div class='method'></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-procout' href='./../Overviews/Methods.html#procout'>procout</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-procout' href='./../Overviews/Methods.html#procout'>procout</a> = <span class='argstr'>newbus</span></h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>newbus<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-hdr' href='./../Overviews/Methods.html#hdr'>hdr</a> </h3>
<div class='method'></div><h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h2><a class='anchor' name='examples'>Examples</a></h2>
<pre class='code prettyprint lang-sc'>s.boot;
(
SynthDef(\singrain, {arg outbus, freq, amp, dur;
    OffsetOut.ar(outbus,
        Pan2.ar(
            SinOsc.ar(freq, 0, amp) *
                EnvGen.kr(Env.sine(dur, amp), doneAction: 2),
            Rand.new(-1.0, 1.0)
        )
    ) // read off the overall env control of the ProcMod
}).add;

// create a new ProcModR, and assign a function to it
a = ProcModR.new(Env([0, 1, 0], [1, 1], \sin, 1), 1, 2, 0, server: s);
a.function_({arg group, routebus, server;
    Task({
        inf.do({
            // start a new synth... run it inside this ProcMod's group,
            // and read control values off the envbus
            server.sendMsg(\s_new, \singrain, server.nextNodeID, 0, group,
                \freq, 440.rrand(1760), \amp, 0.1, \dur, 5, \outbus, routebus);
            0.5.wait;
            })
        });
    });

// play it
a.play;
// change the amp
a.amp_(2);
// change the lag
a.lag_(0.5);
// change the amp again
a.amp_(5);
// release it
a.release;

// creating ProcMods in a functional way

a = {arg amp, env, high, low, winsize, overlaps;
    var proc;
    // defaults to Server.default if no Server is supplied
    proc = ProcModR.new(env, amp, 2, 0);
    proc.function_({arg group, routebus, server;
        Task({
            inf.do({
                // start a new synth... run it inside this ProcMod's group,
                // and read control values off the envbus
                server.sendMsg(\s_new, \singrain, server.nextNodeID, 0, group,
                    \freq, high.rrand(low), \amp, 1, \dur, winsize,
                    \outbus, routebus);
                (winsize / overlaps).wait;
                })
            });
        });
    };

// create new instances of ProcMod... store it to the variables 'b' and 'c'
b = a.value(0.2, Env([0, 1, 0], [1, 1], \sin, 1), 2000, 1000, 0.1, 4);
c = a.value(0.3, Env([0, 1, 0], [10, 0.1], [5, -10], 1), 440, 880, 0.4, 2);

b.play; c.play;

b.release;
c.release;</pre>

<p>Re-triggerable ProcModRs
<p>ProcModRs are meant for the most part, to be played and released. However, if the function slot is passed a Function object, they can be re-triggered after they have been released. If the Function returns a Task or Routine, the ProcMod will function as though a Task or Routine were placed in the function slot (it will be started and released in the same way). Re-triggered events will be assigned a new group and envbus, so these are made available to the Function through arguments. If an OSCresponderNode or releaseFunc are needed for each re-triggered event, they should be assigned inside the Function:<pre class='code prettyprint lang-sc'>s.boot;
(
SynthDef(\trig, {arg id, val;
    SendTrig.kr(Impulse.kr(10), id, val);
    }).add;

SynthDef(\singrain, {arg freq, amp, dur, outbus;
    OffsetOut.ar(outbus,
        Pan2.ar(
            SinOsc.ar(freq, 0, amp) *
                EnvGen.kr(Env.sine(dur, amp), doneAction: 2),
            -1.0.rrand(1.0)
        )
    ) // read off the overall env control of the ProcMod
}).add;
)

i = 0;

a = ProcModR.new(Env([0, 1, 0], [1, 3], \sin, 1), 1, 2, 0, server: s);
// use a function. This one returns the Task. group and envbus are passed in as args
a.function_({arg group, routebus, server;
    a.responder_(
            OSCresponderNode(a.server.addr, '/tr', {arg time, resp, msg;
                (msg[2] == group).if({msg[3].postln})
                })
        );
    Task({
        s.sendMsg(\s_new, \trig, a.server.nextNodeID, 0, group, \id, group,
            \val, i);
        i = i + 1;
        inf.do({
            // start a new synth... run it inside this ProcMod's group,
            // and read control values off the envbus
            server.sendMsg(\s_new, \singrain, server.nextNodeID, 0,
                group, \freq, 440.rrand(880) * i, \amp, 0.1, \dur, 5,
                \outbus, routebus);
            0.05.wait;
            });
        });
    });

a.play; // play the ProcModR
// release the current event, and start a new one immediately. These will overlap.
a.release; a.play; // watch the posted values from the OSCresponderNode
a.release;</pre>

<p>Recording the output of ProcModRs
<p>ProcModRs can record their output (anything that is sent to its private routebus) out to a file with the recordPM method. You just supply a basepath, and other timestamp info is added to it:<pre class='code prettyprint lang-sc'>(
a = {arg amp, env, high, low, winsize, overlaps, path;
var proc;
// defaults to Server.default if no Server is supplied
proc = ProcModR.new(env, amp, 2, 0);
proc.recordPM(path);
proc.function_({arg group, routebus, server;
    Task({
        inf.do({
            // start a new synth... run it inside this ProcMod's group,
            // and read control values off the envbus
            server.sendMsg(\s_new, \singrain, server.nextNodeID, 0, group,
                \freq, high.rrand(low), \amp, 1, \dur, winsize,
                \outbus, routebus);
            (winsize / overlaps).wait;
            })
        });
    });
};
)
// create new instances of ProcMod... store it to the variables 'b' and 'c'
b = a.value(0.2, Env([0, 1, 0], [1, 1], \sin, 1), 2000, 1000, 0.1, 4,
    "~/Desktop/test1".standardizePath); // a base path, other time stamp info is added
c = a.value(0.3, Env([0, 1, 0], [10, 0.1], [5, -10], 1), 440, 880, 0.4, 2,
    "~/Desktop/test2".standardizePath);

b.play; c.play;

b.release;
c.release;</pre>

<p>ProcModR and ProcEvents
<p>ProcModRs is interchangable with ProcMod. The main difference is you can give the .record method to ProcEvents, with a path, and it will use that base path to record every ProcModR out to it's own, timestamped file.<pre class='code prettyprint lang-sc'>s.boot;
(
a = {arg id, amp, env, high, low, winsize, overlaps;
    var proc;
    proc = ProcModR.new(env, amp, 2, 0, id: id);
    proc.function_({arg group, routebus, server;
        Task({
            inf.do({
                // start a new synth... run it inside this ProcMod's group,
                // and read control values off the envbus
                server.sendMsg(\s_new, \singrain, server.nextNodeID, 0, group,
                    \freq, high.rrand(low), \amp, 1, \dur, winsize,
                    \outbus, routebus);
                (winsize / overlaps).wait;
                })
            });
        });
    };

e = ProcEvents.new([
/* 0 */        [a.value(\ev1, 0.1, Env([0, 1, 0], [2, 10], \sin, 1), 440, 880, 0.3, 8),
            nil], // create \ev1, release nothing
/* 1 */        [a.value(\ev2, 0.1, Env([0, 1, 0], [1, 10], \sin, 1), 2200, 4400, 0.2, 8),
            nil],
/* 2 */        [a.value(\ev3, 0.1, Env([0, 1, 0.5, 2, 0], [1, 1, 1, 1], \sin, 1), 100,
                10000, 1, 4),
            [\ev1, \ev2]], // release ev1 and ev2
/* 3 */        [nil, \ev3]
            ], 0.dbamp, id: "test");

e.record("~/Desktop/test".standardizePath, true, 'aiff', 'float');
)

e.perfGUI;</pre>

<p><div class='doclink'>helpfile source: <a href='file:///usr/local/share/SuperCollider/Extensions/SC3plugins/JoshUGens/HelpSource/Classes/ProcModR.schelp'>/usr/local/share/SuperCollider/Extensions/SC3plugins/JoshUGens/HelpSource/Classes/ProcModR.schelp</a><br>link::Classes/ProcModR::<br>sc version: 3.8dev</div></div></body></html>