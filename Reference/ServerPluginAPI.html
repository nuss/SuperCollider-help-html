<html><head><title>Server Plugin API</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider REFERENCE</div>
<div id='categories'><a href='./../Browse.html#Internals'>Internals</a></div>
<h1>Server Plugin API</h1>
<div id='summary'>Reference for writing unit generators</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Guides/WritingUGens.html">Writing Unit Generators</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Input rates'>Input rates</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#UGen basics'>UGen basics</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Buffers'>Buffers</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#RGen'>RGen</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Unary operators'>Unary operators</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Binary operators'>Binary operators</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Constants'>Constants</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Unroll macros'>Unroll macros</a></li>
<ul class='toc'></ul></ul></div><h2><a class='anchor' name='Input rates'>Input rates</a></h2>

<p>These four constants identify the calculation rates of inputs in SuperCollider.<dl>
<dt><code class='code prettyprint lang-sc'>calc_ScalarRate</code><dd>Initial rate. Conventionally known in the language as ".ir".<dt><code class='code prettyprint lang-sc'>calc_BufRate</code><dd>Control rate. Conventionally known in the language as ".kr".<dt><code class='code prettyprint lang-sc'>calc_FullRate</code><dd>Audio rate. Conventionally known in the language as ".ar".<dt><code class='code prettyprint lang-sc'>calc_DemandRate</code><dd>Demand rate.</dl>
<h2><a class='anchor' name='UGen basics'>UGen basics</a></h2>

<p>These helper macros assume that there is a ugen object called <code class='code prettyprint lang-sc'>unit</code> in the local scope.<dl>
<dt><code class='code prettyprint lang-sc'>IN(index)</code><dd>A single block of audio-rate input as a float* at the given index. Index 0 is the first input to the ugen, index 1 the second input, and so forth.<dt><code class='code prettyprint lang-sc'>IN0(index)</code><dd>A single sample of control-rate input as a float, at the given index.<dt><code class='code prettyprint lang-sc'>OUT(index)</code><dd>A single block of audio-rate output as a float* at the given index.<dt><code class='code prettyprint lang-sc'>OUT0(index)</code><dd>A single sample of control-rate input as a float, at the given index.<dt><code class='code prettyprint lang-sc'>INRATE(index)</code><dd>Get the rate of a given input index. This will be one of the four rates.<dt><code class='code prettyprint lang-sc'>INBUFLENGTH(index)</code><dd>Get the block size of a given input index.<dt><code class='code prettyprint lang-sc'>SAMPLERATE</code><dd>Sample rate of the server in Hertz.<dt><code class='code prettyprint lang-sc'>SAMPLEDUR</code><dd>Sample period of the server in seconds.<dt><code class='code prettyprint lang-sc'>BUFLENGTH</code><dd>Length in samples of an audio buffer (that is, the number of samples in a control period).<dt><code class='code prettyprint lang-sc'>BUFRATE</code><dd>Control rate of the server in Hertz.<dt><code class='code prettyprint lang-sc'>BUFDUR</code><dd>Control period of the server in seconds.<dt><code class='code prettyprint lang-sc'>FULLRATE</code><dd><dt><code class='code prettyprint lang-sc'>FULLBUFLENGTH</code><dd></dl>
<h2><a class='anchor' name='Buffers'>Buffers</a></h2>
<dl>
<dt><code class='code prettyprint lang-sc'>GET_BUF</code><dd>The recommended way to retrieve a buffer. Take the first input of this UGen and use it as a buffer number. This dumps a number of variables into the local scope:<ul>
<li><code class='code prettyprint lang-sc'>buf</code> - a pointer to the <code class='code prettyprint lang-sc'>SndBuf</code> instance<li><code class='code prettyprint lang-sc'>bufData</code> - the raw float data from the buffer<li><code class='code prettyprint lang-sc'>bufChannels</code> - the number of channels in the buffer<li><code class='code prettyprint lang-sc'>bufSamples</code> - the number of samples in the buffer<li><code class='code prettyprint lang-sc'>bufFrames</code> - the number of frames in the buffer</ul>

<p>The buffer is locked using the <code class='code prettyprint lang-sc'>LOCK_SNDBUF</code> macro. Buffer lock operations are specific to supernova, and don't do anything in vanilla scsynth.<dt><code class='code prettyprint lang-sc'>GET_BUF_SHARED</code><dd>Like <code class='code prettyprint lang-sc'>GET_BUF</code>, but the buffer is locked using <code class='code prettyprint lang-sc'>LOCK_SNDBUF_SHARED</code>.<dt><code class='code prettyprint lang-sc'>SIMPLE_GET_BUF</code><dd>Like <code class='code prettyprint lang-sc'>GET_BUF</code>, but only creates the <code class='code prettyprint lang-sc'>buf</code> variable and does not lock the buffer.<dt><code class='code prettyprint lang-sc'>SIMPLE_GET_BUF_EXCLUSIVE</code><dd>Like <code class='code prettyprint lang-sc'>SIMPLE_GET_BUF</code>, but locks the buffer with <code class='code prettyprint lang-sc'>LOCK_SNDBUF</code>.<dt><code class='code prettyprint lang-sc'>SIMPLE_GET_BUF_SHARED</code><dd>Like <code class='code prettyprint lang-sc'>SIMPLE_GET_BUF</code>, but locks the buffer with <code class='code prettyprint lang-sc'>LOCK_SNDBUF_SHARED</code>.</dl>

<p>The following macros are for use in supernova. They still exist in scsynth, but will have no effect.<pre class='code prettyprint lang-sc'>ACQUIRE_BUS_AUDIO(index)
ACQUIRE_BUS_AUDIO_SHARED(index)
RELEASE_BUS_AUDIO(index)
RELEASE_BUS_AUDIO_SHARED(index)
LOCK_SNDBUF(buf)
LOCK_SNDBUF_SHARED(buf)
LOCK_SNDBUF2(buf1, buf2)
LOCK_SNDBUF2_SHARED(buf1, buf2)
LOCK_SNDBUF2_EXCLUSIVE_SHARED(buf1, buf2)
LOCK_SNDBUF2_SHARED_EXCLUSIVE(buf1, buf2)
ACQUIRE_SNDBUF(buf)
ACQUIRE_SNDBUF_SHARED(buf)
RELEASE_SNDBUF(buf)
RELEASE_SNDBUF_SHARED(buf)
ACQUIRE_BUS_CONTROL(index)
RELEASE_BUS_CONTROL(index)</pre>
<h2><a class='anchor' name='RGen'>RGen</a></h2>

<p>RGen is a pseudorandom number generator API. Most ugen developers are not interested in seeding their own RGens and would prefer to draw from a global RGen instance supplied by SuperCollider. This can be retrieved with the code:<pre class='code prettyprint lang-sc'>RGen&amp; rgen = *unit-&gt;mParent-&gt;mRGen;</pre>
<dl>
<dt><code class='code prettyprint lang-sc'>uint32 RGen::trand()</code><dd>Return a uniformly distributed random 32-bit integer.<dt><code class='code prettyprint lang-sc'>double RGen::drand()</code><dd>Return a uniformly distributed random double in [0,1).<dt><code class='code prettyprint lang-sc'>float RGen::frand()</code><dd>Random float in [0,1).<dt><code class='code prettyprint lang-sc'>float RGen::frand0()</code><dd>Random float in [1,2).<dt><code class='code prettyprint lang-sc'>float RGen::frand2()</code><dd>Random float in [-1,1).<dt><code class='code prettyprint lang-sc'>float RGen::frand8()</code><dd>Random float in [-0.125,0.125).<dt><code class='code prettyprint lang-sc'>float RGen::fcoin()</code><dd>Either -1 or +1.<dt><code class='code prettyprint lang-sc'>float RGen::flinrand()</code><dd>Linearly distributed random float in [0,1), with a bias towards the 0 end.<dt><code class='code prettyprint lang-sc'>float RGen::fbilinrand()</code><dd>Bilinearly distributed random float in (-1,1), with a bias towards 0.<dt><code class='code prettyprint lang-sc'>float RGen::fsum3rand()</code><dd>A crude but fast approximation to a Gaussian distribution. Results are always in the range (-1,1). The variance is 1/6 and the standard deviation is 0.41.<a class='footnote anchor' name='footnote_org_1' href='#footnote_1'><sup>1</sup></a> <dt><code class='code prettyprint lang-sc'>int32 RGen::irand(int32 scale)</code><dd>Random int in [0,scale).<dt><code class='code prettyprint lang-sc'>int32 RGen::irand2(int32 scale)</code><dd>Random int in [-scale,+scale].<dt><code class='code prettyprint lang-sc'>int32 RGen::ilinrand(int32 scale)</code><dd>Linearly distributed random int in [0,scale), with a bias towards the 0 end.<dt><code class='code prettyprint lang-sc'>int32 RGen::ibilinrand(int32 scale)</code><dd>Bilinearly distributed random int in (-scale,scale), with a bias towards the 0.<dt><code class='code prettyprint lang-sc'>double RGen::linrand()</code><dd>Linearly distributed random double in [0,1), with a bias towards the 0 end.<dt><code class='code prettyprint lang-sc'>double RGen::bilinrand()</code><dd>Bilinearly distributed random double in (-1,1), with a bias towards 0.<dt><code class='code prettyprint lang-sc'>double RGen::exprandrng(double lo, double hi)</code><dd>Exponentially distributed random double in [lo,hi).<dt><code class='code prettyprint lang-sc'>double RGen::exprand(double scale)</code><dd><dt><code class='code prettyprint lang-sc'>double RGen::biexprand(double scale)</code><dd><dt><code class='code prettyprint lang-sc'>double RGen::exprand(double scale)</code><dd><dt><code class='code prettyprint lang-sc'>double RGen::sum3rand(double scale)</code><dd>Double version of <code class='code prettyprint lang-sc'>RGen::fsum3rand</code>.</dl>
<h2><a class='anchor' name='Unary operators'>Unary operators</a></h2>
<dl>
<dt><code class='code prettyprint lang-sc'>bool sc_isnan(float/double x)</code><dd>Checks whether <code class='code prettyprint lang-sc'>x</code> is NaN. This is a legacy function, use <code class='code prettyprint lang-sc'>std::isnan</code> instead.<dt><code class='code prettyprint lang-sc'>bool sc_isfinite(float/double x)</code><dd>Checks whether <code class='code prettyprint lang-sc'>x</code> is finite. This is a legacy function, use <code class='code prettyprint lang-sc'>std::isfinite</code> instead.<dt><code class='code prettyprint lang-sc'>int32 sc_grayCode(int32 x)</code><dd>Convert binary to Gray code.</dl>

<p>The following unary functions are available for both float32 and float64, and are the same as in sclang (minus the "sc_" prefixes):<ul>
<li><code class='code prettyprint lang-sc'>sc_midicps</code><li><code class='code prettyprint lang-sc'>sc_cpsmidi</code><li><code class='code prettyprint lang-sc'>sc_midiratio</code><li><code class='code prettyprint lang-sc'>sc_ratiomidi</code><li><code class='code prettyprint lang-sc'>sc_octcps</code><li><code class='code prettyprint lang-sc'>sc_cpsoct</code><li><code class='code prettyprint lang-sc'>sc_ampdb</code><li><code class='code prettyprint lang-sc'>sc_dbamp</code><li><code class='code prettyprint lang-sc'>sc_cubed</code><li><code class='code prettyprint lang-sc'>sc_sqrt</code><li><code class='code prettyprint lang-sc'>sc_hanwindow</code><li><code class='code prettyprint lang-sc'>sc_welwindow</code><li><code class='code prettyprint lang-sc'>sc_triwindow</code><li><code class='code prettyprint lang-sc'>sc_rectwindow</code><li><code class='code prettyprint lang-sc'>sc_scurve</code><li><code class='code prettyprint lang-sc'>sc_ramp</code><li><code class='code prettyprint lang-sc'>sc_sign</code><li><code class='code prettyprint lang-sc'>sc_distort</code><li><code class='code prettyprint lang-sc'>sc_softclip</code><li><code class='code prettyprint lang-sc'>sc_ceil</code><li><code class='code prettyprint lang-sc'>sc_floor</code><li><code class='code prettyprint lang-sc'>sc_reciprocal</code><li><code class='code prettyprint lang-sc'>sc_frac</code><li><code class='code prettyprint lang-sc'>sc_log2</code> (legacy -- use <code class='code prettyprint lang-sc'>std::log2(std::abs(x))</code>)<li><code class='code prettyprint lang-sc'>sc_log10</code> (legacy -- use <code class='code prettyprint lang-sc'>std::log10(std::abs(x))</code>)<li><code class='code prettyprint lang-sc'>sc_trunc</code> (legacy -- use <code class='code prettyprint lang-sc'>std::trunc</code>)</ul>

<p>The following unary functions are available for both float32 and float64, but have no sclang equivalent:<dl>
<dt><code class='code prettyprint lang-sc'>zapgremlins(x)</code><dd>Replaces NaNs, infinities, very large and very small numbers (including denormals) with zero. This is useful in ugen feedback to safeguard from pathological behavior. (Note lack of sc_ prefix.)<dt><code class='code prettyprint lang-sc'>sc_bitriwindow(x)</code><dd>Alternative to <code class='code prettyprint lang-sc'>sc_triwindow</code> using absolute value.<dt><code class='code prettyprint lang-sc'>sc_scurve0(x)</code><dd>Same as <code class='code prettyprint lang-sc'>sc_scurve</code>, but assumes that <code class='code prettyprint lang-sc'>x</code> is in the interval [0, 1].<dt><code class='code prettyprint lang-sc'>sc_distortneg(x)</code><dd>A one-sided distortion function. Same as <code class='code prettyprint lang-sc'>distort</code> for <code class='code prettyprint lang-sc'>x &gt; 0</code>, and the identity function for <code class='code prettyprint lang-sc'>x &lt;= 0</code>.<dt><code class='code prettyprint lang-sc'>taylorsin(x)</code><dd>Taylor series approximation of <code class='code prettyprint lang-sc'>sin(x)</code> out to <code class='code prettyprint lang-sc'>x**9 / 9!</code>. (Note lack of sc_ prefix.)<dt><code class='code prettyprint lang-sc'>sc_lg3interp(x1, a, b, c, d)</code><dd>Cubic Lagrange interpolator.<dt><code class='code prettyprint lang-sc'>sc_CalcFeedback(delaytime, decaytime)</code><dd>Determines the feedback coefficient for a feedback comb filter with the given delay and decay times.<dt><code class='code prettyprint lang-sc'>sc_wrap1(x)</code><dd>Wrap <code class='code prettyprint lang-sc'>x</code> around ±1, wrapping only once.<dt><code class='code prettyprint lang-sc'>sc_fold1(x)</code><dd>Fold <code class='code prettyprint lang-sc'>x</code> around ±1, folding only once.</dl>
<h2><a class='anchor' name='Binary operators'>Binary operators</a></h2>
<dl>
<dt><code class='code prettyprint lang-sc'>sc_wrap(in, lo, hi [, range])</code><dd><dt><code class='code prettyprint lang-sc'>sc_fold(in, lo, hi [, range [, range2]])</code><dd><dt><code class='code prettyprint lang-sc'>sc_pow(a, b)</code><dd>Compute <code class='code prettyprint lang-sc'>pow(a, b)</code>, retaining the sign of <code class='code prettyprint lang-sc'>a</code>.<dt><code class='code prettyprint lang-sc'>sc_powi(x, unsigned int n)</code><dd>Compute <code class='code prettyprint lang-sc'>x^n</code>, not necessarily retaining the sign of <code class='code prettyprint lang-sc'>x</code>.<dt><code class='code prettyprint lang-sc'>sc_hypotx(x, y)</code><dd>Compute <code class='code prettyprint lang-sc'>abs(x) + abs(y) - (min(abs(x), abs(y)) * (sqrt(2) - 1))</code>, the minimum distance one will have to travel from the origin to (x,y) using only orthogonal and diagonal movements.</dl>

<p>The following functions are the same as in sclang (minus the "sc_" prefixes):<ul>
<li><code class='code prettyprint lang-sc'>sc_mod(in, hi)</code> (floats, doubles, ints)<li><code class='code prettyprint lang-sc'>sc_round(x, quant)</code> (floats, doubles, ints)<li><code class='code prettyprint lang-sc'>sc_roundUp(x, quant)</code> (floats, doubles, ints)<li><code class='code prettyprint lang-sc'>sc_trunc(x, quant)</code> (floats, doubles, ints)<li><code class='code prettyprint lang-sc'>sc_gcd(a, b)</code> (ints, longs, floats)<li><code class='code prettyprint lang-sc'>sc_lcm(a, b)</code> (ints, longs, floats)<li><code class='code prettyprint lang-sc'>sc_bitAnd(a, b)</code> (ints)<li><code class='code prettyprint lang-sc'>sc_bitOr(a, b)</code> (ints)<li><code class='code prettyprint lang-sc'>sc_leftShift(a, b)</code> (ints)<li><code class='code prettyprint lang-sc'>sc_rightShift(a, b)</code> (ints)<li><code class='code prettyprint lang-sc'>sc_unsignedRightShift(a, b)</code> (ints)<li><code class='code prettyprint lang-sc'>sc_thresh(a, b)</code><li><code class='code prettyprint lang-sc'>sc_clip2(a, b)</code><li><code class='code prettyprint lang-sc'>sc_wrap2(a, b)</code><li><code class='code prettyprint lang-sc'>sc_fold2(a, b)</code><li><code class='code prettyprint lang-sc'>sc_excess(a, b)</code><li><code class='code prettyprint lang-sc'>sc_scaleneg(a, b)</code><li><code class='code prettyprint lang-sc'>sc_amclip(a, b)</code><li><code class='code prettyprint lang-sc'>sc_ring1(a, b)</code><li><code class='code prettyprint lang-sc'>sc_ring2(a, b)</code><li><code class='code prettyprint lang-sc'>sc_ring3(a, b)</code><li><code class='code prettyprint lang-sc'>sc_ring4(a, b)</code><li><code class='code prettyprint lang-sc'>sc_difsqr(a, b)</code><li><code class='code prettyprint lang-sc'>sc_sumsqr(a, b)</code><li><code class='code prettyprint lang-sc'>sc_sqrsum(a, b)</code><li><code class='code prettyprint lang-sc'>sc_sqrdif(a, b)</code><li><code class='code prettyprint lang-sc'>sc_atan2(a, b)</code> (legacy -- use <code class='code prettyprint lang-sc'>std::atan2</code>)</ul>
<h2><a class='anchor' name='Constants'>Constants</a></h2>

<p>The following constants are doubles:<ul>
<li><code class='code prettyprint lang-sc'>pi</code><li><code class='code prettyprint lang-sc'>pi2</code> = pi/2<li><code class='code prettyprint lang-sc'>pi32</code> = 3pi/2<li><code class='code prettyprint lang-sc'>twopi</code> = 2pi<li><code class='code prettyprint lang-sc'>rtwopi</code> (1/2pi)<li><code class='code prettyprint lang-sc'>log001</code> = log(0.001)<li><code class='code prettyprint lang-sc'>log01</code> = log(0.01)<li><code class='code prettyprint lang-sc'>log1</code> = log(0.1)<li><code class='code prettyprint lang-sc'>rlog2</code> = 1/log(2)<li><code class='code prettyprint lang-sc'>sqrt2</code> = sqrt(2)<li><code class='code prettyprint lang-sc'>rsqrt2</code> = 1/sqrt(2)<li><code class='code prettyprint lang-sc'>truncDouble</code> = 3 * 2^51 (used to truncate precision)</ul>

<p>The following constants are floats:<ul>
<li><code class='code prettyprint lang-sc'>pi_f</code><li><code class='code prettyprint lang-sc'>pi2_f</code><li><code class='code prettyprint lang-sc'>pi32_f</code><li><code class='code prettyprint lang-sc'>twopi_f</code><li><code class='code prettyprint lang-sc'>sqrt2_f</code><li><code class='code prettyprint lang-sc'>rsqrt2_f</code><li><code class='code prettyprint lang-sc'>truncFloat</code> = 3 * 2^22 (used to truncate precision)</ul>
<h2><a class='anchor' name='Unroll macros'>Unroll macros</a></h2>

<p>The macros in this section are legacy features. They are seen in many of SuperCollider's built-in ugens, and are intended to provide more efficient alternatives to the standard <code class='code prettyprint lang-sc'>for (int i = 0; i &lt; inNumSamples; i++) { out[i] = in[i] }</code> loop. These efficiency savings are negligible on modern systems and use of these macros is not recommended, especially since they make debugging difficult.<dl>
<dt><code class='code prettyprint lang-sc'>LOOP(length, stmt)</code><dd>Execute code <code class='code prettyprint lang-sc'>stmt</code>, <code class='code prettyprint lang-sc'>length</code> times.<dt><code class='code prettyprint lang-sc'>LOOP1(length, stmt)</code><dd>A faster drop-in alternative to <code class='code prettyprint lang-sc'>LOOP</code>, which assumes that <code class='code prettyprint lang-sc'>length &gt; 0</code> so a branch instruction is saved.<dt><code class='code prettyprint lang-sc'>LooP(length) stmt</code><dd>An alternative to LOOP/LOOP1 that is more debugger-friendly. The body of the loop comes after the call to <code class='code prettyprint lang-sc'>LooP</code>.<dt><code class='code prettyprint lang-sc'>ZIN(index)</code><dd>Similar to <code class='code prettyprint lang-sc'>IN</code>, but subtracts 1 from the pointer to correct for off-by-one errors when using <code class='code prettyprint lang-sc'>LOOP</code> and <code class='code prettyprint lang-sc'>ZXP</code>.<dt><code class='code prettyprint lang-sc'>ZOUT(index)</code><dd>Same as <code class='code prettyprint lang-sc'>OUT</code>, but subtracts 1 from the pointer to correct for off-by-one errors when using <code class='code prettyprint lang-sc'>LOOP</code> and <code class='code prettyprint lang-sc'>ZXP</code>.<dt><code class='code prettyprint lang-sc'>ZIN0(index)</code><dd>Alias for <code class='code prettyprint lang-sc'>IN0</code>.<dt><code class='code prettyprint lang-sc'>ZOUT0(index)</code><dd>Alias for <code class='code prettyprint lang-sc'>OUT0</code>.<dt><code class='code prettyprint lang-sc'>ZXP(z)</code><dd>Pre-increment and dereference <code class='code prettyprint lang-sc'>z</code>.<dt><code class='code prettyprint lang-sc'>ZX(z)</code><dd>Dereference <code class='code prettyprint lang-sc'>z</code>.<dt><code class='code prettyprint lang-sc'>PZ(z)</code><dd>Pre-increment <code class='code prettyprint lang-sc'>z</code>.<dt><code class='code prettyprint lang-sc'>ZP(z)</code><dd>Does nothing.<dt><code class='code prettyprint lang-sc'>ZOFF</code><dd>Return 1.</dl>
<div class='footnotes'>
<a class='anchor' name='footnote_1'/><div class='footnote'>[<a href='#footnote_org_1'>1</a>] - The formula is <code class='code prettyprint lang-sc'>(rand() + rand() + rand() - 1.5) * 2/3</code>, technically a shifted and stretched order-3 Irwin-Hall distribution.</div></div><div class='doclink'>helpfile source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Reference/ServerPluginAPI.schelp'>/usr/local/share/SuperCollider/HelpSource/Reference/ServerPluginAPI.schelp</a><br>link::Reference/ServerPluginAPI::<br>sc version: 3.8dev</div></div></body></html>