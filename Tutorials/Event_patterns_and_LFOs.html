<!doctype html><html lang='en'><head><title>Event patterns and LFOs | SuperCollider 3.11.2 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'Event patterns and LFOs';
var scdoc_sc_version = '3.11.2';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>Event patterns and LFOs:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#1.%20Control%20by%20new%20values%20per%20event'>1. Control by new values per event</a></li>
<ul class='toc'><li class='toc2'><a href='#Ex.1a:%20Functions%20of%20time'>Ex.1a: Functions of time</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.1b:%20Envelopes'>Ex.1b: Envelopes</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.1c:%20SharedOut%20/%20shared%20memory'>Ex.1c: SharedOut / shared memory</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.1d:%20HS%20/%20PHS%20and%20related'>Ex.1d: HS / PHS and related</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.1e:%20audio%20synths%20reading%20from%20a%20control%20bus,%20discretized'>Ex.1e: audio synths reading from a control bus, discretized</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.1f:%20Pseg'>Ex.1f: Pseg</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#2.%20Continuous%20LFO%20control'>2. Continuous LFO control</a></li>
<ul class='toc'><li class='toc2'><a href='#Ex.2a:%20audio%20synths%20reading%20from%20a%20control%20bus'>Ex.2a: audio synths reading from a control bus</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.2b:%20audio%20synths%20mapped%20to%20a%20control%20bus'>Ex.2b: audio synths mapped to a control bus</a></li>
<ul class='toc'></ul></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Tutorials (extension)</span>
 | <span id='categories'><a href='./../Browse.html#Libraries'>Libraries</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>miSCellaneous'>miSCellaneous</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>miSCellaneous>General Tutorials'>General Tutorials</a> | <a href='./../Browse.html#Streams-Patterns-Events'>Streams-Patterns-Events</a></span>
</div><h1>Event patterns and LFOs<div class='extension-indicator-ctr' title='This help file originates from a third-party quark or plugin for SuperCollider.'><img class='extension-indicator-icon' alt='Extension' src='./../images/plugin.png'><span class='extension-indicator-text'>Extension</span></div></h1>
<div id='summary'>summary of some LFO control strategies for event patterns</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Overviews/miSCellaneous.html">miSCellaneous</a>, <a href="./../Guides/Introduction_to_miSCellaneous.html">Introduction to miSCellaneous</a>, <a href="./../Guides/Guide_to_HS_and_HSpar.html">Guide to HS and HSpar</a>, <a href="./../Classes/VarGui.html">VarGui</a>, <a href="./../Tutorials/VarGui_shortcut_builds.html">VarGui shortcut builds</a>, <a href="./../Tutorials/HS_with_VarGui.html">HS with VarGui</a></div>
</div>
<h2><a class='anchor' name='description'>Description</a></h2>

<p>Basic distinction: synths generated by an event pattern can be controlled directly by a LFO (synths wired or mapped to control buses) or on a per-event base. The latter can be achieved by language-only strategies or with help of control synths. For the sake of clarity most examples use the default instrument and pitch as control parameter.<h2><a class='anchor' name='1.%20Control%20by%20new%20values%20per%20event'>1. Control by new values per event</a></h2>

<p><a class='anchor' name='Ex.1a'>&nbsp;</a> <h3><a class='anchor' name='Ex.1a:%20Functions%20of%20time'>Ex.1a: Functions of time</a></h3>
<textarea class='editor'>(
s = Server.local;
Server.default = s;
s.boot;
)


(
// LFO defined as Function

f = { |x| (x * 2).sin * 3 + (x * 0.3).sin }; 

p = Pbind( 
    \dev, Ptime().collect(f), // current time passed to function
    \midinote, Pkey(\dev) + 60 + [0, 4], 
    \amp, 0.05, 
    \dur, 0.15 
).play; 
)

p.stop;


////////////////////////// 

// example with GUI


(
// parametric control function

f = { |x| (x * ~a[0]).sin * ~b[0] + ((x * ~a[1]).sin * ~b[1]) }; 

p = Pbind( 
    \dev, Ptime().collect(f), 
    \midinote, Pkey(\dev) + 60 + [0, 4], 
    \amp, 0.05,
    \dur, 0.15 
); 

v = VarGui([
    \a, { [0, 10, \lin, 0.01, rrand(0.0, 10)] } ! 2,
    \b, { [0, 10, \lin, 0.01, rrand(0.0, 10)] } ! 2],
    stream: p
).gui
)

// add a hook that re-plots control function after every slider change

(
u = Plotter(bounds: Rect(200, 200, 700, 500));

// evaluation points

x = (0, 0.1..20);

// EventStreamPlayer is run in separate Environment, 
// function values have to be polled from there,
// evaluate function initially and add it as mouseUp slider action

g = { u.value_(f.inEnvir(v.envirs.first).(x)).refresh };

g.();

v.addSliderAction(g);
)



////////////////////////// 

// GUI example with two LFOs


(
// parametric control function

f = { |x| (x * ~a[0]).sin * ~b[0] + ((x * ~a[1]).sin * ~b[1]) }; 

p = Pbind( 
    \dev, Ptime().collect(f), 
    \midinote, Pkey(\dev) + Pfunc { ~add }, 
    \amp, 0.05,
    \dur, 0.15 
); 

// add some harmonies

q = Padd(\midinote, [-12, -7, 0, 5], p);
r = Padd(\midinote, [0, 2.5], p);

v = VarGui([70, 55].collect { |x| [
    \a, { [0, 5, \lin, 0.01, rrand(0.0, 5)] } ! 2,
    \b, { [0, 5, \lin, 0.01, rrand(0.0, 5)] } ! 2,
    \add, [x-2, x+2, \lin, 0.01, x]
    ] }, stream: [r,q], quant: 0.15
).gui
)

// add a hook that re-plots control function after every slider change

(
u = Plotter(bounds: Rect(200, 200, 700, 500));

// evaluation points

x = (0, 0.1..20);

// EventStreamPlayer is run in separate Environment, 
// function values have to be polled from there,
// evaluate function initially and add it as mouseUp slider action

g = { u.value_(v.envirs.collect { |e| f.inEnvir(e).(x) }).refresh };


g.();

v.addSliderAction(g);
)</textarea>

<p><a class='anchor' name='Ex.1b'>&nbsp;</a> <h3><a class='anchor' name='Ex.1b:%20Envelopes'>Ex.1b: Envelopes</a></h3>
<textarea class='editor'>(
e = Env([0, 10, 0], [2,1], \sin);
e.plot;
)

// currently (SC 3.4.4) this will play the envelope once 
// and then continue with the end value

(
p = Pbind( 
    \dev, e, 
    \midinote, Pkey(\dev) + 60 + [0, 4], 
    \amp, 0.05, 
    \dur, 0.15 
).play; 
)

p.stop;


// you can use modulo calculus for looping

(
p = Pbind( 
    \dev, Ptime().collect { |t| e[t % (e.times.sum)] }, 
    \midinote, Pkey(\dev) + 60 + [0, 4], 
    \amp, 0.05, 
    \dur, 0.15 
).play; 
)

p.stop;


////////////////////////// 

// example with GUI

(
n = 5;

p = Pbind( 
    \dev, Ptime().collect { |t| e[t % (e.times.sum)] }, 
    \midinote, Pkey(\dev) + 60 + [0, 4], 
    \amp, 0.05, 
    \dur, 0.15 
);

v = VarGui([
    \levels, { [-15, 15, \lin, 0.01, rrand(-15.0, 15)] } ! n,
    \times, { [0.5, 3, \lin, 0.01, rrand(0.5, 3)] } ! (n-1),
    \curves, { [0, 7, \lin, 1, rrand(0, 7)] } ! (n-1),
    \stretch, [0.1, 10, \lin, 0.01, 1]],
    stream: p
).gui;
)

// add a hook that plots envelope after every slider change

(
u = Plotter(bounds: Rect(200, 200, 700, 500));

g = { 
    v.envirs.first.use { e = Env(~levels, ~times * ~stretch, ~curves) };
    u.value_(e.asSignal).refresh; 
};

g.();

v.addSliderAction(g);
)</textarea>

<p><a class='anchor' name='Ex.1c'>&nbsp;</a> <h3><a class='anchor' name='Ex.1c:%20SharedOut%20/%20shared%20memory'>Ex.1c: SharedOut / shared memory</a></h3>

<p>SharedOut will be deprecated in future releases of SC and replaced by a shared memory mechanism (Tim Blechmann).  SharedOut is at least included in version 3.4.4.<textarea class='editor'>// internal server needed for all examples with SharedOut,
// shared memory also works with local server

(
s = Server.internal;
Server.default = s;
s.boot;
)

// start LFO

x = { SharedOut.kr(0, LFDNoise3.kr(0.3, 20, 70)) }.play;


// play event pattern

(
p = Pbind(
    \dur, 0.15, 
    \midinote, Pfunc { s.getSharedControl(0) }
).play;
)
    
(
p.stop;
x.free;
)

////////////////////////// 

// example with GUI

// ATTENTION: this version of the example works with SC versions &gt; 3.4.4
// in which SharedOut is still supported and which already include 
// the fix of a minor bug which blocked adding of SynthDefs.
// See below for an equivalent example with shared memory.

// If you're using a version &lt;= 3.4.4 you can fix it by yourself, 
// adding this method to SharedOut and recompile:
// *numFixedArgs { ^1 }

// ... or take the example version below the following version

(
s = Server.internal;
Server.default = s;
s.boot;
)

(
SynthDef(\control, { |midiCenter, dev, devFreq| SharedOut.kr(0, LFDNoise3.kr(devFreq, dev, midiCenter)) }).add;

p = Pbind(
    \dur, 0.15, 
    \midinote, Pfunc { s.getSharedControl(0) } + [0, 4]
);

// start control synth before stream
    
v = VarGui(synthCtr: [
    \midiCenter, [50, 80, \lin, 0.01, 70],
    \dev, [0, 20, \lin, 0.01, 20],
    \devFreq, [0, 3, \lin, 0.01, 0.5]],
    synth: \control, stream: p
).gui(playerPriority: \synth);
)


// this version of the example works also with SC versions &lt;= 3.4.4
  
(
SynthDef(\control, { |midiCenter, dev, devFreq| SharedOut.kr(0, LFDNoise3.kr(devFreq, dev, midiCenter)) }).send(s);
)

(
x = Synth(\control).register;  

// or start paused:
// x = Synth.newPaused(\control).register; 

p = Pbind(
    \dur, 0.15, 
    \midinote, Pfunc { s.getSharedControl(0) } + [0, 4]
);
)    

(
v = VarGui(synthCtr: [
    \midiCenter, [50, 80, \lin, 0.01, 70],
    \dev, [0, 20, \lin, 0.01, 20],
    \devFreq, [0, 3, \lin, 0.01, 0.5]],
    synth: x, stream: p
).gui(playerPriority: \synth);
)


// shared memory example, SC version &gt;= 3.5
// start LFO

c = Bus.control(s, 1);

x = { Out.kr(c, LFDNoise3.kr(0.3, 20, 70)) }.play;


// play event pattern

(
p = Pbind(
    \dur, 0.15, 
    \midinote, Pfunc { c.getSynchronous }
).play;
)
 
(
p.stop;
x.free;
)</textarea>

<p><a class='anchor' name='Ex.1d'>&nbsp;</a> <h3><a class='anchor' name='Ex.1d:%20HS%20/%20PHS%20and%20related'>Ex.1d: HS / PHS and related</a></h3>

<p>With <a href="./../Classes/HS.html">HS</a> server values can be used in <a href="./../Classes/PHS.html">PHS</a> objects which mimic event patterns. This is achieved by an OSC demand and respond mechanism which introduces a small amount of additional latency. It works with local and internal server, see <a href="./../Guides/Guide_to_HS_and_HSpar.html">Guide to HS and HSpar</a> for further details. Using the HS family with VarGui is discussed in <a href="./../Tutorials/HS_with_VarGui.html">HS with VarGui</a>. 
<p>The HS / PHS approach would especially be of interest if control behaviour could more easily be defined by server means than in SC lang (e.g. specific and / or nested UGens) but data should also be further manipulated in the language (e.g. for some kind of combinatorial use such as harmonic or polyphonic calculations).<textarea class='editor'>(
s = Server.local;
Server.default = s;
s.boot;
)

// a HS contains the control synth definition but will also hold playing Synth instances

h = HS(s, { |midiCenter = 70, dev = 20, devFreq = 1| LFDNoise3.kr(devFreq, dev, midiCenter) });


// a PHS refers to a HS and, when played, takes control over the control synth

p = PHS(h, [], 0.15, [ \midinote, Pkey(\val) + [0, 4] ]).play;


// stop player and control synth 

p.free;</textarea>

<p>Methods of linked playing / stopping and resuming (stream + help synth) are supported as well as reference to an already playing <a href="./../Classes/HS.html">HS</a> by <a href="./../Classes/PHSuse.html">PHSuse</a>. Various kinds of control synth control and synth value reference are possible with two or more help synths (see <a href="./../Classes/HSpar.html">HSpar</a>, <a href="./../Classes/PHSpar.html">PHSpar</a> and <a href="./../Classes/PHSparUse.html">PHSparUse</a>). 
<p><a class='anchor' name='Ex.1e'>&nbsp;</a> <h3><a class='anchor' name='Ex.1e:%20audio%20synths%20reading%20from%20a%20control%20bus,%20discretized'>Ex.1e: audio synths reading from a control bus, discretized</a></h3>

<p>Derived from (2a), disadvantage: SynthDef must be adapted to control needs beforehand.<textarea class='editor'>(
c = Bus.control(s,1);
d = Bus.control(s,1);

SynthDef(\perc_1e, {|amp = 0.1, bus, att = 0.01, rel = 1|
    var in = In.kr(bus, 1);
    Out.ar(0, (SinOsc.ar(Latch.kr(in, in).midicps, 0, amp) * 
        EnvGen.ar(Env.perc(att, rel), doneAction: 2))!2)
}).add;
)

(
x = { Out.kr(c, LFDNoise3.kr(1, 5, 75)) }.play;
y = { Out.kr(d, LFDNoise3.kr(1, 5, 65)) }.play;

p = Pbind(
    \instrument, \perc_1e,
    \dur, 0.3,
    \amp, 0.07,
    \bus, [c, d]
).play;
)

(
p.stop;
x.free;
y.free;
)</textarea>

<p><a class='anchor' name='Ex.1f'>&nbsp;</a> <h3><a class='anchor' name='Ex.1f:%20Pseg'>Ex.1f: Pseg</a></h3>

<p>Pseg can work like a kind of meta pattern for LFO-like control, patterns are used to pass envelope data.<textarea class='editor'>(
p = Pbind(
    \note, Pseg(Pseq([0, Pwhite(3, 10, 1)], inf), Pseq([1, 3],inf), 'lin'),
    \dur, 0.2
).play;
)

p.stop;</textarea>
<h2><a class='anchor' name='2.%20Continuous%20LFO%20control'>2. Continuous LFO control</a></h2>

<p><a class='anchor' name='Ex.2a'>&nbsp;</a> <h3><a class='anchor' name='Ex.2a:%20audio%20synths%20reading%20from%20a%20control%20bus'>Ex.2a: audio synths reading from a control bus</a></h3>

<p>The disadvantage of this strategy (compared to 2b) is that synth definitions have to be written especially for control purposes. It must be known in advance which parameters should be controlled by another synth.<textarea class='editor'>(
c = Bus.control(s,1);

SynthDef(\perc_2a, {|amp = 0.1, bus = 0, att = 0.01, rel = 0.25|
    Out.ar(0, (SinOsc.ar(In.kr(bus, 1).midicps, 0, amp) * 
        EnvGen.ar(Env.perc(att, rel), doneAction: 2))!2)
}).add;
)

(
x = { Out.kr(c, LFDNoise3.kr(3, 10, 65)) }.play;

p = Pbind(
    \instrument, \perc_2a,
    \dur, 0.3,
    \bus, c
).play;
)

(
p.stop;
x.free;
)</textarea>

<p><a class='anchor' name='Ex.2b'>&nbsp;</a> <h3><a class='anchor' name='Ex.2b:%20audio%20synths%20mapped%20to%20a%20control%20bus'>Ex.2b: audio synths mapped to a control bus</a></h3>

<p>In general more practical than (2a), though by SC vs 3.4.4 reserved keys (e.g. \freq) can't be mapped to a bus, under these circumstances args would have to be renamed.<textarea class='editor'>(
c = Bus.control(s,1);
d = Bus.control(s,1);

SynthDef(\perc_2b, {|amp = 0.1, midi = 60, att = 0.01, rel = 0.25|
    Out.ar(0, (SinOsc.ar(midi.midicps, 0, amp) * 
        EnvGen.ar(Env.perc(att, rel), doneAction: 2))!2)
}).add;
)

(
x = { Out.kr(c, LFDNoise3.kr(1, 5, 75)) }.play;
y = { Out.kr(d, LFDNoise3.kr(1, 5, 65)) }.play;

p = Pbind(
    \instrument, \perc_2b,
    \dur, 0.3,
    \midi, [c, d].collect(_.asMap)
).play;
)

(
p.stop;
x.free;
y.free;
)


////////////////////////// 

// example with GUI


(
c = Bus.control(s,1);
d = Bus.control(s,1);

SynthDef(\perc_2b, {|amp = 0.1, midi = 60, att = 0.01, rel = 0.25|
    Out.ar(0, (SinOsc.ar(midi.midicps, 0, amp) * 
        EnvGen.ar(Env.perc(att, rel), doneAction: 2))!2)
}).add;

SynthDef(\control_2b, { |midiCenter = 70, dev = 20, devFreq = 1, out = 0| 
    Out.kr(out, LFDNoise3.kr(devFreq, dev, midiCenter)) 
}).add;
)

(
p = Pbind(
    \instrument, \perc_2b,
    \dur, Pfunc { ~dur },
    // following values will be collections of two elements
    \amp, Pfunc { ~amp },
    \att, Pfunc { ~att },
    \rel, Pfunc { ~rel },
    \midi, [c, d].collect(_.asMap)
);

// in gui start control synths before stream player !

v = VarGui([
    \dur, [0.05, 0.5, \lin, 0.005, 0.2],
    // setting envir variables to collections of two elements
    \amp, [0, 0.1, \lin, 0.005, 0.07] ! 2,
    \att, [0.005, 0.1, \lin, 0.005, 0.01] ! 2,
    \rel, [0.005, 0.5, \lin, 0.005, 0.1] ! 2
    ],
    2.collect { |i| 
        var bus = [c,d][i].index;
        [\midiCenter, [60, 80, \lin, 0.01, [65, 75][i] ],
        \dev, [0, 10, \lin, 0.01, 10],
        \devFreq, [0, 3, \lin, 0.01, 0.5],
        \out, [bus, bus, \lin, 1, bus]] 
    }, p, \control_2b ! 2 
).gui(sliderPriority: \synth, playerPriority: \synth);
)</textarea>
<div class='doclink'>helpfile source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Tutorials/Event_patterns_and_LFOs.schelp'>/home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Tutorials/Event_patterns_and_LFOs.schelp</a><br>link::Tutorials/Event_patterns_and_LFOs::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>