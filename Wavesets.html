<html><head><title>Wavesets</title>
<link rel='stylesheet' href='./scdoc.css' type='text/css' />
<link rel='stylesheet' href='./frontend.css' type='text/css' />
<link rel='stylesheet' href='./custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./scdoc.js' type='text/javascript'></script>
<script src='./docmap.js' type='text/javascript'></script>
<script src='./prettify.js' type='text/javascript'></script>
<script src='./lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='.';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider  (extension)</div>
<div id='categories'><a href='./Browse.html#GranularSynthesis'>GranularSynthesis</a></div>
<h1>Wavesets</h1>
<div id='summary'>analyse soundfiles into short fragments for granular synthesis</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./Classes/Buffer.html">Buffer</a>, <a href="./Classes/Event.html">Event</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*prepareSynthDefs'>prepareSynthDefs</a> </li>
<li class='toc3'><a href='#*all'>all</a> </li>
<li class='toc3'><a href='#*at'>at</a> </li>
<li class='toc3'><a href='#*clear'>clear</a> </li>
<li class='toc3'><a href='#*from'>from</a> </li>
<li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc3'><a href='#*minLength'>minLength</a> </li>
<li class='toc3'><a href='#*defaultInst'>defaultInst</a> </li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Instance variables'>Instance variables</a></li>
<ul class='toc'><li class='toc3'><a href='#-signal'>signal</a> </li>
<li class='toc3'><a href='#-name'>name</a> </li>
<li class='toc3'><a href='#-buffer'>buffer</a> </li>
<li class='toc3'><a href='#-numFrames'>numFrames</a> </li>
<li class='toc3'><a href='#-sampleRate'>sampleRate</a> </li>
<li class='toc3'><a href='#-numXings'>numXings</a> </li>
<li class='toc3'><a href='#-lengths'>lengths</a> </li>
<li class='toc3'><a href='#-amps'>amps</a> </li>
<li class='toc3'><a href='#-maxima'>maxima</a> </li>
<li class='toc3'><a href='#-minima'>minima</a> </li>
<li class='toc3'><a href='#-fracXings'>fracXings</a> </li>
<li class='toc3'><a href='#-fracLengths'>fracLengths</a> </li>
<li class='toc3'><a href='#-maxSet'>maxSet</a> </li>
<li class='toc3'><a href='#-avgLength'>avgLength</a> </li>
<li class='toc3'><a href='#-sqrAvgLength'>sqrAvgLength</a> </li>
<li class='toc3'><a href='#-minAmp'>minAmp</a> </li>
<li class='toc3'><a href='#-maxAmp'>maxAmp</a> </li>
<li class='toc3'><a href='#-avgAmp'>avgAmp</a> </li>
<li class='toc3'><a href='#-sqrAvgAmp'>sqrAvgAmp</a> </li>
<li class='toc3'><a href='#-minima'>minima</a> </li>
<li class='toc3'><a href='#-frameFor'>frameFor</a> </li>
<li class='toc3'><a href='#-analyse'>analyse</a> </li>
<li class='toc3'><a href='#-analyseFromTo'>analyseFromTo</a> </li>
<li class='toc3'><a href='#-calcAverages'>calcAverages</a> </li>
<li class='toc3'><a href='#-toBuffer'>toBuffer</a> </li>
<li class='toc3'><a href='#-plot'>plot</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>Wavesets analyses soundfiles into short fragments called wavesets, and contains these waveset data and their info. It can support a variety of waveset based synthesis instruments.
<p>By Trevor Wishart's definition, a waveset is a segment of an audio signal between one non-positive to positive zero crossing and the next. [ see T. Wishart (1994): Audible Design. ] Note that this definition only applies to mono signals.
<p>In extension of that concept, the Wavesets class provides fractional zero crossings, amplitude analyses, and other statistical data.
<p>See also the end of Chapter 16, Microsound, in the SuperCollider Book at MIT Press for detailed examples - code available here: 
<p><a href="http://supercolliderbook.net/">http://supercolliderbook.net/</a><pre class='code prettyprint lang-sc'>    // first code example: 

Server.default = s = Server.internal; s.boot;
        
        // make a wavesets from a soundfile
w = Wavesets.from(String.scDir +/+ "sounds/a11wlk01.wav");    
w.dump;        // contains mainly analysis data 
                
w.plot(200, 1);    // plot a single waveset
w.signal.copyRange(w.xings[600], w.xings[601]).plot;

w.plot(600, 1);    // a single
w.plot(600, 5);    // a group of five contiguous wavesets
w.buffer;
w.buffer.play;
    
Wavesets.prepareSynthDefs;
    // startWs
w.eventFor(startWs: 600, length: 5, repeats: 2).postln.play;
w.eventFor(startWs: 600, length: 2, playRate: 1, repeats: 5).postln.play;
w.eventFor(startWs: 600, length: 2, playRate: 0.5, repeats: 5).postln.play;
w.eventFor(700, 20, 5, 1).play;
        
(
fork { 
    666.do { |i| 
        var ev = w.eventFor(i * 5, 2, 5, exprand(0.5, 1.0)); 
        ev.put(\pan, 1.0.rand2).play;
        ev.sustain.wait;
    }
};
)</pre>
<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*prepareSynthDefs' href='./Overviews/Methods.html#prepareSynthDefs'>prepareSynthDefs</a> </h3>
<div class='method'>
<p>prepare some basic synthdefs that can be used for Wavesets synthesis (when using the eventFor method).</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*all' href='./Overviews/Methods.html#all'>all</a> </h3>
<div class='method'>
<p>global dict for all instances of Wavesets</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*at' href='./Overviews/Methods.html#at'>at</a> </h3>
<div class='method'>
<p>access instances in Wavesets.all by name (key).<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>key<td class='argumentdesc'>
<p>a symbol.</table></div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*clear' href='./Overviews/Methods.html#clear'>clear</a> </h3>
<div class='method'>
<p>clear all existing wavesets from the Wavesets.all.</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*from' href='./Overviews/Methods.html#from'>from</a> </h3>
<div class='method'>
<p>make a Wavesets from a <em>MONO</em> soundfile at path.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>the path to the soundfile.<tr><td class='argumentname'>name<td class='argumentdesc'>
<p>the name by which to store the Wavesets instance.<tr><td class='argumentname'>toBuffer<td class='argumentdesc'>
<p>flag whether to make a buffer that that soundfile. default = true.<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the server on which to load the soundfile. default = s.</table></div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./Overviews/Methods.html#new'>new</a> </h3>
<div class='method'>
<p>make a new Wavesets instance. *from is much more common.</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*minLength' href='./Overviews/Methods.html#minLength'>minLength</a> </h3>
<div class='method'>
<p>The minimum number of sample points a single Waveset can have. This is used to avoid lots of extremely short samples in noisy samples. Logical minimum is 2, default is 10.</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*defaultInst' href='./Overviews/Methods.html#defaultInst'>defaultInst</a> </h3>
<div class='method'>
<p>get and set the name of the default synthdef to use in Wavesets event-related methods.</div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3><a class='anchor' name='Instance variables'>Instance variables</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-signal' href='./Overviews/Methods.html#signal'>signal</a> </h3>
<div class='method'>
<p>the audio signal that was analysed. </div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-name' href='./Overviews/Methods.html#name'>name</a> </h3>
<div class='method'>
<p>the wavesets name in the global dictionary</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-buffer' href='./Overviews/Methods.html#buffer'>buffer</a> </h3>
<div class='method'>
<p>a buffer on the server that was created from the same soundfile</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-numFrames' href='./Overviews/Methods.html#numFrames'>numFrames</a> </h3>
<div class='method'>
<p>the number of frames of the soundfile, the buffer and the Wavesets</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sampleRate' href='./Overviews/Methods.html#sampleRate'>sampleRate</a> </h3>
<div class='method'>
<p>the sample rate of the signal/buffer. default is s.sampleRate
<p><strong>These variables are analysis result lists: method</strong> xings  all integer indices of the zero crossings found</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-numXings' href='./Overviews/Methods.html#numXings'>numXings</a> </h3>
<div class='method'>
<p>total number of zero crossings found</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-lengths' href='./Overviews/Methods.html#lengths'>lengths</a> </h3>
<div class='method'>
<p>lengths of all wavesets</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-amps' href='./Overviews/Methods.html#amps'>amps</a> </h3>
<div class='method'>
<p>peak amplitude of every waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-maxima' href='./Overviews/Methods.html#maxima'>maxima</a> </h3>
<div class='method'>
<p>indices of positive maximum value in every waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-minima' href='./Overviews/Methods.html#minima'>minima</a> </h3>
<div class='method'>
<p>indices of negative minimum value in every waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-fracXings' href='./Overviews/Methods.html#fracXings'>fracXings</a> </h3>
<div class='method'>
<p>the calculated fractional zerocrossing points. This allows for more precise pitch information and waveset transitions, resulting in smoother sound.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-fracLengths' href='./Overviews/Methods.html#fracLengths'>fracLengths</a> </h3>
<div class='method'>
<p>fractional lengths - in effect, this is 1/wavesetFreq.
<p><strong>These are overall statistics of the entire Wavesets: method</strong> minSet shorted waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-maxSet' href='./Overviews/Methods.html#maxSet'>maxSet</a> </h3>
<div class='method'>
<p>longest waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-avgLength' href='./Overviews/Methods.html#avgLength'>avgLength</a> </h3>
<div class='method'>
<p>average length of all wavesets</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sqrAvgLength' href='./Overviews/Methods.html#sqrAvgLength'>sqrAvgLength</a> </h3>
<div class='method'>
<p>weighted average length - so bigger wavesets have a larger impact</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-minAmp' href='./Overviews/Methods.html#minAmp'>minAmp</a> </h3>
<div class='method'>
<p>softest waveset amplitude</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-maxAmp' href='./Overviews/Methods.html#maxAmp'>maxAmp</a> </h3>
<div class='method'>
<p>loudest waveset amplitude</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-avgAmp' href='./Overviews/Methods.html#avgAmp'>avgAmp</a> </h3>
<div class='method'>
<p>average amplitude of the entire waveset</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sqrAvgAmp' href='./Overviews/Methods.html#sqrAvgAmp'>sqrAvgAmp</a> </h3>
<div class='method'>
<p>weighted average of (squared) amplitude of the entire waveset
<p><strong>Instance methods METHOD</strong> eventFor generate an event for a given combination of start waveset index, number of wavesets, repeats, playback rate, and use of fractional crossings.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>startWs, numWs, repeats, playRate, useFrac<td class='argumentdesc'></table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-minima' href='./Overviews/Methods.html#minima'>minima</a> </h3>
<div class='method'>
<p></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-frameFor' href='./Overviews/Methods.html#frameFor'>frameFor</a> </h3>
<div class='method'>
<p></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-analyse' href='./Overviews/Methods.html#analyse'>analyse</a> </h3>
<div class='method'>
<p>analyse the entire soundfile, then do finishFunc</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-analyseFromTo' href='./Overviews/Methods.html#analyseFromTo'>analyseFromTo</a> </h3>
<div class='method'>
<p>analyse the soundfile from given startFrame to endFrame</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-calcAverages' href='./Overviews/Methods.html#calcAverages'>calcAverages</a> </h3>
<div class='method'>
<p>analysis to do after loading.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-toBuffer' href='./Overviews/Methods.html#toBuffer'>toBuffer</a> </h3>
<div class='method'>
<p>create a buffer for the Waevesets on the server given.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-plot' href='./Overviews/Methods.html#plot'>plot</a> </h3>
<div class='method'>
<p>plot a section of &lt;length&gt; Wavesets from &lt;startWs&gt;</div><h2><a class='anchor' name='examples'>Examples</a></h2>
<pre class='code prettyprint lang-sc'>The simplest usage is to ask the waveset to prepare an event for you.

        w = Wavesets.from("sounds/a11wlk01.wav");    

    (
        fork { 
            666.do { |i| 
                var ev = w.eventFor((i * 5).postln, 2, 5, exprand(0.5, 1.0)); 
                ev.put(\pan, 1.0.rand2).play;
                ev.sustain.wait;
            }
        };        
    )




    // play a single waveset or waveset group by hand
(
{     var startFr, endFr, dur; 
    startFr = w.xings[800]; 
    endFr = w.xings[820];
    
    dur = endFr - startFr / w.buffer.sampleRate;
    dur.postln;
    BufRd.ar(1, w.buffer, Line.ar(startFr, endFr, dur, doneAction: 2)) 
}.play;
)

    loop buffer segments with a Phasor:
(
x = { arg start = 0, end = 128, playRate = 1; 
    BufRd.ar(1, w.buffer, 
        Phasor.ar(0, playRate * BufRateScale.kr(w.buffer), start, end)
    )
}.scope(zoom: 8);
)

x.set(\start, 0, \end, 1024);    // just some random length, may buzz
x.set(\start, w.xings.at(100), \end, w.xings.at(101));
x.set(\start, w.xings.at(101), \end, w.xings.at(102));
x.set(\start, w.xings.at(100), \end, w.xings.at(200));
x.set(\start, w.xings.at(780), \end, w.xings.at(800));
x.set(\playRate, 0.25);
x.set(\playRate, 1);

x.release;</pre>

<p>Doing Some Task (optional)
<p>Examples<pre class='code prettyprint lang-sc'>To play a waveset (or group) for a precise number of repetitions, 
one can use a SynthDef with a hard cutoff envelope, as below.
Note that adding an offset outside the phasor works better; 
Phasor.ar(0, playRate, start, end) is sometimes off by a few samples.
This is likely a 32bit float precision problem.

(    // the simplest synthdef as implented in *prepareSynthDefs: 
SynthDef(\wvst0, { arg out = 0, buf = 0, start = 0, length = 441, playRate = 1, sustain = 1, amp=0.2, pan; 
    var phasor = Phasor.ar(0, BufRateScale.ir(buf) * playRate, 0, length) + start;
    var env = EnvGen.ar(Env([amp, amp, 0], [sustain, 0]), doneAction: 2);
    var snd = BufRd.ar(1, buf, phasor) * env;
    
    OffsetOut.ar(out, Pan2.ar(snd, pan));
}, \ir.dup(8)).memStore;
)

Synth("wvst0", [\bufnum, b, \start, 0, \length, 5000, \sustain, 0.1]);

    // do the math by hand to understand it:
(
var startWs = 100, length = 6, rep = 10, playRate = 0.5;
var startframe, endframe, sustain;

startframe = w.xings[startWs];
endframe = w.xings[startWs + length];
sustain = (endframe - startframe) * rep / playRate / w.sampleRate; 

Synth("wvst0", [
    \bufnum, w.buffer, 
    \start, startframe, 
    \length, endframe - startframe, 
    \playRate, playRate,
    \sustain, sustain, 
    \amp, 1
]);
)
    // the same done with eventFor:
w.eventFor(100, 6, repeats: 10, playRate: 0.5).put(\amp, 1).play;

(
Task({ 
    300.do({ arg i; 
        var ev = w.eventFor(100 + i, 2, 10, 1);
                
        ev.putPairs([\pan, [-1, 1].choose, \amp, 0.5]);
        ev.play;
        (ev.sustain).wait; 
    });
}).play;
)

x = a11wlk01-44_1.aiff; 

        // compare fractional and integer xings:
        // especially for high frequency signals, 
        // fractional does slightly cleaner looping and finer pitch gradations.
        // - better test below with ordering wavesets by length -
(
Task({ 
    [true, false].do { |usefrac| 
        (1250..1500).do { arg i; 
            var ev = w.eventFor(i, 1, 100, 1, useFrac: usefrac);
                    
            ev.putPairs([/*\pan, 0 [-1, 1].choose,*/ \amp, 0.5]);
            ev.play;
            (ev.sustain).wait; 
        };
        1.wait;
    };
}).play;
)

        // some variants waveset timestretch
(
Task({ 
        // segments of 10 wavesets, step by 1 =&gt; 10x longer
    (300, 301 .. 900).do { arg start; 
        var ev = w.eventFor(start, numWs: 10, repeats: 1);
                
        ev.putPairs([\amp, 0.5]);
        ev.play;
        (ev.sustain).wait; 
    };
    1.wait; 

        // 1 waveset at a time, loop 10 times - much more 'pitch beads'-like
    (300, 301 .. 900).do { arg start; 
        var ev = w.eventFor(start, numWs: 1, repeats: 10);
                
        ev.putPairs([\amp, 0.5]);
        ev.play;
        (ev.sustain).wait; 
    };
    
}).play;
)



    // play them sorted by (integer) waveset length: 
w.lengths.plot;    // lengths are very irregular
o = w.lengths.order;

(
Task {
    var start, end, startFr, endFr, dur, repeats;
    var order = w.lengths.order;
        
    [false, true].do { |useFrac| 
        if (useFrac) { 
            "fractional crossings - better pitch resolution." 
        } {
            "integer crossings - pitches quantized to integer sample lengths."
        }.postln;
        
        order.do { arg start; 
            var ev = w.eventFor(start, numWs: 1, repeats: 5);
            ev.putPairs([\amp, 0.5]);
            ev.play;
            (ev.sustain).wait;
        };
        0.5.wait;
    };
}.play;
)</pre>
<div class='doclink'>source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/Wavesets/HelpSource/Wavesets.schelp'>/home/stefan/.local/share/SuperCollider/downloaded-quarks/Wavesets/HelpSource/Wavesets.schelp</a><br>link::Wavesets::<br>sc version: 3.7alpha1</div></div></body></html>