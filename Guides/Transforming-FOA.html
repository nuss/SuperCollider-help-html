<!doctype html><html lang='en'><head><title>Transforming FOA | SuperCollider 3.11.2 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'Transforming FOA';
var scdoc_sc_version = '3.11.2';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>Transforming FOA:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#Imaging'>Imaging</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Choose%20a%20decoder'>Choose a decoder</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Dynamic%20examples'>Dynamic examples</a></li>
<ul class='toc'><li class='toc2'><a href='#Rotate'>Rotate</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#DominateX'>DominateX</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Focus'>Focus</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Push%20and%20RTT'>Push and RTT</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Push%20and%20RTT%20with%20newSpread'>Push and RTT with newSpread</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#FocusX,%20ZoomX%20&%20PushX'>FocusX, ZoomX &amp; PushX</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Balance%20and%20Asymmetry'>Balance and Asymmetry</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Proximity'>Proximity</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#NFC'>NFC</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Static%20examples'>Static examples</a></li>
<ul class='toc'><li class='toc2'><a href='#Rotate'>Rotate</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#MirrorO'>MirrorO</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#DominateX'>DominateX</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Transform%20utilities'>Transform utilities</a></li>
<ul class='toc'></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Guides (extension)</span>
 | <span id='categories'><a href='./../Browse.html#Libraries'>Libraries</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>Ambisonic Toolkit'>Ambisonic Toolkit</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>Ambisonic Toolkit>Guides & Tutorials'>Guides & Tutorials</a></span>
</div><h1>Transforming FOA<div class='extension-indicator-ctr' title='This help file originates from a third-party quark or plugin for SuperCollider.'><img class='extension-indicator-icon' alt='Extension' src='./../images/plugin.png'><span class='extension-indicator-text'>Extension</span></div></h1>
<div id='summary'>First Order Ambisonic (FOA) transforming examples</div>
</div>
<div class='subheader'>
</div>
<a class='anchor' name='kw_Atk'>&nbsp;</a><h2><a class='anchor' name='Imaging'>Imaging</a></h2>

<p>For the artist, the real power of the ATK is found in the imaging transforms. These are spatial domain filters which reorient, reshape or otherwise spatially filter an input soundfield. Many users will be familiar with the soundfield rotation transform, as SuperCollider provides the inbuilt <a href="./../Classes/Rotate2.html">Rotate2</a>.
<p>The ATK provides a much wider and comprehensive toolset, including:<ul>
<li><em>rotation:</em> soundfield rotation about an axis<li><em>mirror:</em> soundfield reflection across an axis<li><em>directivity:</em> soundfield directivity<li><em>dominance:</em> adjust directional gain of soundfield<li><em>focus:</em> focus on a region of a soundfield<li><em>push:</em> push a soundfield in a direction</ul>

<p>Imaging tools are provided in two forms: <a href="./../Classes/FoaXform.html">static</a> and <a href="./../Classes/FoaTransform.html">dynamic</a> implementations. While most transforms are provided in both categories, a number are found in only one guise.<a class='footnote anchor' name='footnote_org_1' href='#footnote_1'><sup>1</sup></a> 
<p>The examples below are intended to briefly illustrate some of the first order tranform options made available in the Ambisonic Toolkit.<div class='note'><span class='notelabel'>NOTE:</span> See <a href="./../Classes/FoaTransform.html">FoaTransform</a>, <a href="./../Classes/FoaXform.html">FoaXform</a> and <a href="./../Classes/FoaXformerMatrix.html">FoaXformerMatrix</a> for more details regarding FOA imaging.</div>
<p>________________<div class='note'><span class='notelabel'>NOTE:</span> The text immediate below follows a workflow in explicit sclang. For a quick review, you may prefer to jump below to try the included <a href="#Transform%20utilities">transform audition and visualization utilities</a>.</div><h2><a class='anchor' name='Choose%20a%20decoder'>Choose a decoder</a></h2>

<p>With the examples below, we'll start by first choosing a suitable decoder with with to audition.
<p>Choose a decoder suitable for your system, as discussed <a href="./../Guides/Intro-FOA-Examples.html#Choose%20a%20decoder">here</a>. You'll end up definining <code>~decoder</code> and <code>~renderDecode</code> .<div class='note'><span class='notelabel'>NOTE:</span> If you choose a kernel decoder, <a href="./../Classes/FoaDecoderKernel.html">FoaDecoderKernel</a>, be sure to free the kernel after use.</div><h2><a class='anchor' name='Dynamic%20examples'>Dynamic examples</a></h2>

<p>Dynamic transforms are rendered via UGens accepting continuously varying arguments. The below examples use the <a href="./../Classes/FoaTransform.html">FoaTransform</a> wrapper as a convenience. Users may choose to employ the underlying wrapped UGen, as desired. These are noted for each example below.<h3><a class='anchor' name='Rotate'>Rotate</a></h3>

<p>Rotation is one of the most used soundfield transforms. In this case we'll it to centre the subject of a field recording.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a>, which specifies the rotation angle (pi to -pi; left to right of display).
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A UGen type transformer, see <a href="./../Classes/FoaRotate.html">FoaRotate</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// rotate transformer
// b-format soundfile read from disk

// choose transformer
~transformer = 'rotate'



// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Courville-Dialogue.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Hodges-Purcell.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Leonard-Orfeo_Trio.wav")


(
{
    var sig;                            // audio signal
    var azim;                           // azimuth control


    // display transformer &amp; decoder
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);


    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, azim);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>D. Courville, "Comparative Surround Recording," Ambisonic Studio | Comparative Surround Recording, 2007. [Online]. Available: <a href="http://www.radio.uqam.ca/ambisonic/comparative_recording.html">http://www.radio.uqam.ca/ambisonic/comparative_recording.html</a> [Accessed: 26-Jul-2011].<li>P. Hodges, "Purcell - Passacaglia (King Arthur)," Sound of Space: ambisonic surround sound. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/52">http://soundofspace.com/ambisonic_files/52</a> [Accessed: 03-Nov-2011].<li>J. Leonard, "The Orfeo Trio &amp; TetraMic," Sound of Space: ambisonic surround sound. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/41">http://soundofspace.com/ambisonic_files/41</a> [Accessed: 03-Nov-2011].</ul>
</div><h3><a class='anchor' name='DominateX'>DominateX</a></h3>

<p>Dominance specified in gain is a classic Ambisonic production technique. Here we apply gain across the X axis. With these example recordings, we adjust both the stage width and the subject to reverb balance.
<p>The soundfield is controlled by <a href="./../Classes/MouseY.html">MouseY</a>, which specifies the dominance gain (4.5 dB to -4.5 dB; top to bottom of display).
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A UGen type transformer, see <a href="./../Classes/FoaDominateX.html">FoaDominateX</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// dominateX transformer
// b-format soundfile read from disk

// choose transformer
~transformer = 'dominateX'



// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Courville-Dialogue.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Hodges-Purcell.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Leonard-Orfeo_Trio.wav")


(
{
    var sig;                            // audio signal
    var gain;                           // gain control


    // display transformer &amp; decoder
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // gain ---&gt; top            = +4.5db for front
    //            bottom        = -4.5db for front
    gain = MouseY.kr(4.5, 4.5.neg);


    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, gain);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>D. Courville, "Comparative Surround Recording," Ambisonic Studio | Comparative Surround Recording, 2007. [Online]. Available: <a href="http://www.radio.uqam.ca/ambisonic/comparative_recording.html">http://www.radio.uqam.ca/ambisonic/comparative_recording.html</a> [Accessed: 26-Jul-2011].<li>P. Hodges, "Purcell - Passacaglia (King Arthur)," Sound of Space: ambisonic surround sound. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/52">http://soundofspace.com/ambisonic_files/52</a> [Accessed: 03-Nov-2011].<li>J. Leonard, "The Orfeo Trio &amp; TetraMic," Sound of Space: ambisonic surround sound. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/41">http://soundofspace.com/ambisonic_files/41</a> [Accessed: 03-Nov-2011].</ul>
</div><h3><a class='anchor' name='Focus'>Focus</a></h3>

<p>Here we encode four channels of decorrelated and comb filtered <a href="./../Classes/PinkNoise.html">PinkNoise</a> as a decorrelated soundfield, resulting in a maximally diffuse soundfield. <a href="./../Classes/FoaFocus.html">FoaFocus</a> is used to "focus" on various parts of the soundfield. At extremes, it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction. This technique gives the opportunity to continuously modulate between a directional and a diffuse soundfield.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaFocus.html">FoaFocus</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains decorrelated. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A UGen type transformer, see <a href="./../Classes/FoaFocus.html">FoaFocus</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// focus transformer
// decorrelated, comb filtered pink noise source


// define encoder matrix
~encoder = FoaEncoderMatrix.newAtoB

// choose transformer
~transformer = 'focus'

(
{
    var sig;                // audio signal
    var angle, azim;            // angle and azimuth control
    var freq;


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // frequencies
    freq = 220;

    // angle ---&gt; top         = push to plane wave
    //          bottom    = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //          centre     = centre
    //          hard right     = back
    azim = MouseX.kr(pi, -pi);


    // ------------------------------------------------------------
    // test sig
    sig = PinkNoise.ar([1, 1, 1, 1]); // 4 channels decorrelated pink noise

    // ------------------------------------------------------------
    // comb filter
    sig = HPF.ar(sig, freq);
    sig = CombL.ar(sig, freq.reciprocal, freq.reciprocal, mul: 9.neg.dbamp);


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='Push%20and%20RTT'>Push and RTT</a></h3>

<p>Here we encode four channels of <a href="./../Classes/Klank.html">Klank</a> resonated <a href="./../Classes/Dust.html">Dust</a> from A-format. <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction. This technique gives the opportunity to continuously modulate between a directional and a spatially active soundfield. Additionally, <a href="./../Classes/FoaRTT.html">FoaRTT</a> is used to continuously reorient the granular stream so that individual A-format directions don't predominate, and the complete soundfield is filled with activity.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains decorrelated. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformers, see <a href="./../Classes/FoaPush.html">FoaPush</a> and <a href="./../Classes/FoaRTT.html">FoaRTT</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// push and rtt transformer
// granular klank stream source


// define encoder matrix
~encoder = FoaEncoderMatrix.newAtoB

// choose transformer
~transformer1 = 'rtt'
~transformer2 = 'push'

(
{
    var sig;                     // audio signal
    var angle, azim;            // angle and azimuth control
    var freq;

    // ir...
    var gain = -18;

    var freqs = [50.0, 7000.0], gains = [-24, 0], rtimes = [0.1, 2.0];
    var frequencies, amplitudes, ringTimes;
    var numModes = 20;

    var density = 20;                  // grain/klank density

    var rttFreq = 10 * density;


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic transforming via % transformer".format(~transformer1).postln;
    "Ambisonic transforming via % transformer".format(~transformer2).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;


    // calculate klank args
    frequencies = Array.rand(numModes, freqs[0], freqs[1]).sort;
    amplitudes = Array.rand(numModes, gains[0], gains[1]).sort.reverse.dbamp;
    ringTimes = Array.rand(numModes, rtimes[0], rtimes[1]).sort.reverse;


    // angle ---&gt; top         = push to plane wave
    //          bottom    = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //          centre     = centre
    //          hard right     = back
    azim = MouseX.kr(pi, -pi);


    // ------------------------------------------------------------
    // test sig
    sig = Dust.ar(Array.fill(4, density / 4));

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform 1 (rtt)
    sig = FoaTransform.ar(
        sig,
        ~transformer1,
        LFSaw.ar(rttFreq, pi, add: pi),
        LFSaw.ar(rttFreq**(1/3), pi, add: pi),
        LFSaw.ar(rttFreq**(2/3), pi, add: pi)
    );


    // ------------------------------------------------------------
    // Klank
    sig = gain.dbamp * Klank.ar(
        `[ frequencies, amplitudes, ringTimes ],
        sig
    );


    // ------------------------------------------------------------
    // transform 2 (push)
    sig = FoaTransform.ar(sig, ~transformer2, angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='Push%20and%20RTT%20with%20newSpread'>Push and RTT with newSpread</a></h3>

<p>Here we encode the mono component of a stereo soundfile via the <a href="./../Classes/FoaEncoderKernel.html#*newSpread">FoaEncoderKernel: *newSpread</a> encoder. <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction. This technique gives the opportunity to continuously modulate between a directional and a spatially spread soundfield. Additionally, <a href="./../Classes/FoaRTT.html">FoaRTT</a> is used to continuously reorient the frequency spread soundfield so that individual frequencies are moved throughout the space, and the complete soundfield is constantly in motion.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains decorrelated. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformers, see <a href="./../Classes/FoaPush.html">FoaPush</a>, <a href="./../Classes/FoaRTT.html">FoaRTT</a> and <a href="./../Classes/FoaEncoderKernel.html#*newSpread">FoaEncoderKernel: *newSpread</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// push and rtt transformer
// spreader encoder
// stereo soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderKernel.newSpread(0000)
~encoder = FoaEncoderKernel.newSpread(0001)
~encoder = FoaEncoderKernel.newSpread(0006)
~encoder = FoaEncoderKernel.newSpread(0008)
~encoder = FoaEncoderKernel.newSpread(0010)
~encoder = FoaEncoderKernel.newSpread(0012)

// free kernel (when you swap encoders!)
~encoder.free

// inspect
~encoder
~encoder.kind
~encoder.numChannels
~encoder.dirChannels.raddeg


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-The_Downfall.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-An_Old.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Lux_Aeterna.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Dies_Irae.wav")

// free buffer (when you swap buffers!)
~sndbuf.free


(
{
    var sig;                            // audio signal
    var angle, azim;                    // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top           = push to plane wave
    //            bottom        = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile
    sig = 0.5 * sig.sum; // to mono


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaRTT.ar(sig,
        LFNoise2.kr(1.0/5.0, pi),
        LFNoise2.kr(1.0/5.0, pi),
        LFNoise2.kr(1.0/5.0, pi)
    );
    sig = FoaTransform.ar(sig, 'push', angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// free kernel
~encoder.free
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='FocusX,%20ZoomX%20&%20PushX'>FocusX, ZoomX &amp; PushX</a></h3>

<p>With this example we encode four channels of comb filtered <a href="./../Classes/Dust.html">Dust</a> as planewaves arriving from the cardinal directions. <a href="./../Classes/FoaFocusX.html">FoaFocusX</a>, <a href="./../Classes/FoaZoomX.html">FoaZoomX</a> and <a href="./../Classes/FoaPushX.html">FoaPushX</a> are used to distort the soundfield. At extremes, encoded planewaves are distorted to arrive from the same direction. This example allows one to compare these transforms on the x-axis.
<p>The soundfield is controlled by <a href="./../Classes/MouseY.html">MouseY</a>, with <strong>angle</strong> varying between -pi/2 and pi/2. With the mouse in the centre of the display, the soundfield remains unchanged. Placed at the top or bottom of the display, the soundfield is distorted.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformers, see <a href="./../Classes/FoaFocusX.html">FoaFocusX</a>, <a href="./../Classes/FoaZoomX.html">FoaZoomX</a> &amp; <a href="./../Classes/FoaPushX.html">FoaPushX</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// x-axis transformers
// comb filtered dust noise source, at cardinal points


// define encoder matricies, for each cardinal point
(
~encoder = [
    FoaEncoderMatrix.newDirection,
    FoaEncoderMatrix.newDirection(pi/2),
    FoaEncoderMatrix.newDirection(pi),
    FoaEncoderMatrix.newDirection(pi.neg/2)
]
)

// choose transformer
~transformer = 'focusX'
~transformer = 'zoomX'
~transformer = 'pushX'

(
{
    var sig;                            // audio signal
    var angle;                          // angle control
    var freq;
    var density = 10;                   // grain density


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder[0].kind).postln;
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // frequencies
    freq = 220 * [ 4, 5, 7, 6 ] / 4;

    // angle ---&gt; top           = pi/2
    //            bottom        = -pi/2
    angle = MouseY.kr(pi/2, pi.neg/2);


    // ------------------------------------------------------------
    // test sig
    sig = Dust.ar(Array.fill(4, density / 4));


    // ------------------------------------------------------------
    // comb filter
    sig = BPF.ar(sig, freq, mul: 18.dbamp);
    sig = CombL.ar(sig, freq.reciprocal, freq.reciprocal, mul: 9.neg.dbamp);


    // ------------------------------------------------------------
    // encode
    sig = Mix.fill(sig.numChannels, { arg i;  FoaEncode.ar(sig[i], ~encoder[i]) });


    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, angle);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='Balance%20and%20Asymmetry'>Balance and Asymmetry</a></h3>

<p>With with the <a href="#x-axis:_focusx,_zoomx_&_pushx">above example</a> we encode four channels of comb filtered <a href="./../Classes/Dust.html">Dust</a> as planewaves arriving from the cardinal directions. <a href="./../Classes/FoaZoomY.html">FoaZoomY</a> and <a href="./../Classes/FoaAsymmetry.html">FoaAsymmetry</a> are used to distort the soundfield. At extremes, encoded planewaves are distorted to arrive from the same direction. This example allows one to compare these transforms on the y-axis.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a>, with <strong>angle</strong> varying between -pi/2 and pi/2. With the mouse in the centre of the display, the soundfield remains unchanged. Placed at the left or right of the display, the soundfield is distorted.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformers, see <a href="./../Classes/FoaZoomY.html">FoaZoomY</a> and <a href="./../Classes/FoaAsymmetry.html">FoaAsymmetry</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// y-axis transformers
// comb filtered dust noise source, at cardinal points


// define encoder matricies, for each cardinal point
(
~encoder = [
    FoaEncoderMatrix.newDirection,
    FoaEncoderMatrix.newDirection(pi/2),
    FoaEncoderMatrix.newDirection(pi),
    FoaEncoderMatrix.newDirection(pi.neg/2)
]
)

// choose transformer
~transformer = 'balance'
~transformer = 'asymmetry'

(
{
    var sig;                            // audio signal
    var angle;                          // angle control
    var freq;
    var density = 10;                   // grain density


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder[0].kind).postln;
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // frequencies
    freq = 220 * [ 4, 5, 7, 6 ] / 4;

    // angle ---&gt; left          = pi/2
    //            right         = -pi/2
    angle = MouseX.kr(pi/2, pi.neg/2);


    // ------------------------------------------------------------
    // test sig
    sig = Dust.ar(Array.fill(4, density / 4));


    // ------------------------------------------------------------
    // comb filter
    sig = BPF.ar(sig, freq, mul: 18.dbamp);
    sig = CombL.ar(sig, freq.reciprocal, freq.reciprocal, mul: 9.neg.dbamp);


    // ------------------------------------------------------------
    // encode
    sig = Mix.fill(sig.numChannels, { arg i;  FoaEncode.ar(sig[i], ~encoder[i]) });


    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, angle);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='Proximity'>Proximity</a></h3>

<p><a href="./../Classes/FoaProximity.html">FoaProximity</a> facilitates the introduction of the <a href="http://en.wikipedia.org/wiki/Proximity_effect_(audio)">proximity effect</a> to encoded signals. At extremes, the proximity effect introduces a strong bass boost, as well as phase differences. The <a href="http://en.wikipedia.org/wiki/Proximity_effect_(audio)">proximity effect</a> can be an important contributor to perceptions of nearness.
<p>The soundfield is controlled by <a href="./../Classes/MouseY.html">MouseY</a>, with <strong>distance</strong> varying between 0.05 and 0.5 meter. With the mouse at the bottom of the display, the soundfield receives the strongest effect, contributing to as sense of nearness.<div class='warning'><span class='warninglabel'>WARNING:</span> As <a href="./../Classes/FoaProximity.html">FoaProximity</a> includes a 1st-order integration, signals must be highpass filtered before application. <a href="./../Classes/HPF.html">HPF</a> is usually a suitable choice to control low frequency boost.</div>
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformer, see <a href="./../Classes/FoaProximity.html">FoaProximity</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// proximity transform
// comb filtered dust noise source, panned across the front


// define encoder matricies
(
~encoder = [
    FoaEncoderMatrix.newDirection(pi/6),
    FoaEncoderMatrix.newDirection(pi/12),
    FoaEncoderMatrix.newDirection(pi.neg/12),
    FoaEncoderMatrix.newDirection(pi.neg/6)
]
)

// choose transformer
~transformer = 'proximity'

(
{
    var sig;                            // audio signal
    var dist;                           // distance control
    var freq;
    var density = 10;                   // grain density


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder[0].kind).postln;
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // frequencies
    freq = 220 * [ 4, 5, 7, 6 ] / 4;

    // dist  ---&gt; top           = 0.5
    //            bottom        = 0.05
    dist = MouseY.kr(0.5, 0.05);


    // ------------------------------------------------------------
    // test sig
    sig = Dust.ar(Array.fill(4, density / 4));


    // ------------------------------------------------------------
    // comb filter
    sig = BPF.ar(sig, freq, mul: 18.dbamp);
    sig = CombL.ar(sig, freq.reciprocal, freq.reciprocal, mul: 9.neg.dbamp);


    // ------------------------------------------------------------
    // encode
    sig = Mix.fill(sig.numChannels, { arg i;  FoaEncode.ar(sig[i], ~encoder[i]) });


    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, dist);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</textarea>
<h3><a class='anchor' name='NFC'>NFC</a></h3>

<p><a href="./../Classes/FoaNFC.html">FoaNFC</a> facilitates the reduction or removal of the <a href="http://en.wikipedia.org/wiki/Proximity_effect_(audio)">proximity effect</a> from encoded signals. The <a href="http://en.wikipedia.org/wiki/Proximity_effect_(audio)">proximity effect</a> can be an important contributor to perceptions of nearness.
<p>The soundfield is controlled by <a href="./../Classes/MouseY.html">MouseY</a>, with <strong>distance</strong> varying between 0.5 and 0.05 meter. With the mouse at the top of the display, the soundfield receives the strongest effect (removal), contributing to as sense of distance.
<p>If you haven't already choosen a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> UGen type transformer, see <a href="./../Classes/FoaNFC.html">FoaNFC</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// NFC transform
// b-format soundfile read from disk




// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Anderson-Nearfield.wav")


// choose transformer
~transformer = 'nfc'


(
{
    var sig;                            // audio signal
    var dist;                           // distance control



    // display encoder and decoder
    "Ambisonic transforming via % transformer".format(~transformer).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // dist  ---&gt; top           = 0.05
    //            bottom        = 1.0
    dist = MouseY.kr(0.05, 1.0);


    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile


    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, ~transformer, dist);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Joseph Anderson, "Near-field source," [unpublished recording]</ul>
</div><h2><a class='anchor' name='Static%20examples'>Static examples</a></h2>

<p>Rather than using the UGen wrapper <a href="./../Classes/FoaTransform.html">FoaTransform</a> to render dynamicly changing spatial filtering, as <a href="#Dynamic%20examples">above</a>, <a href="./../Classes/FoaXform.html">FoaXform</a> is used to render the transform specified by <a href="./../Classes/FoaXformerMatrix.html">FoaXformerMatrix</a>, which returns a fixed spatial filtering matrix.
<p>This functionality is provided to complete the matrix processing paradim of the ATK.<h3><a class='anchor' name='Rotate'>Rotate</a></h3>

<p>Rotation is one of the most used soundfield transforms. In this case we'll it to centre the subject of a field recording.
<p>If you haven't already choose a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type transformer, see <a href="./../Classes/FoaXformerMatrix.html#*newRotate">FoaXformerMatrix: *newRotate</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// rotate xformer
// b-format soundfile read from disk


// define xformer matrix
~xformer = FoaXformerMatrix.newRotate           // no rotation --&gt; try this 1st
~xformer = FoaXformerMatrix.newRotate(-110.degrad) // by -110deg   --&gt; try this 2nd


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels.raddeg


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Leonard-Chinook.wav")


(
{
    var sig;                            // audio signal


    // display xformer &amp; decoder
    "Ambisonic transforming via % xformer".format(~xformer.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // transform
    sig = FoaXform.ar(sig, ~xformer);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>J. Leonard, "A couple of Chinook helicopters," Sound of Space: ambisonic surround sound, 20-Mar-2008. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/47">http://soundofspace.com/ambisonic_files/47</a> [Accessed: 03-Nov-2011].</ul>
</div><h3><a class='anchor' name='MirrorO'>MirrorO</a></h3>

<p>In mirroring through the origin and delaying the soundfield, we can generate a new set of echos in this fireworks field recording.
<p>If you haven't already choose a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type transformer, see <a href="./../Classes/FoaXformerMatrix.html#*newMirrorO">FoaXformerMatrix: *newMirrorO</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// mirrorO xformer
// b-format soundfile read from disk


// define xformer matrix
~xformer = FoaXformerMatrix.newMirrorO


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels.raddeg


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Leonard-Fireworks.wav")


(
{
    var sig;                            // audio signal
    var delSig;                         // delayed signal
    var freq;                           // lp frequency
    var delay;                          // delay time
    var scale;                          // delay gain (as scale)

    // display xformer &amp; decoder
    "Ambisonic transforming via % xformer".format(~xformer.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // parameters
    freq = 1200;                        // in Hz
    delay = 0.5;                        // in seconds
    scale = 9.neg.dbamp;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // delay, lp and gain
    delSig = LPF.ar(DelayN.ar(sig, delay, delay), freq, scale);

    // ------------------------------------------------------------
    // transform
    delSig = FoaXform.ar(delSig, ~xformer);

    // ------------------------------------------------------------
    // sum (comment this out to hear original signal)
    sig = sig + delSig;
//    sig = delSig;                    // or listen to the mirrored sig

    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>J. Leonard, "Fireworks," Sound of Space: ambisonic surround sound, 25-Aug-2009. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/37">http://soundofspace.com/ambisonic_files/37</a> [Accessed: 03-Nov-2011].</ul>
</div><h3><a class='anchor' name='DominateX'>DominateX</a></h3>

<p>Dominance adjusts the gain of a soundfield in a particular direction. Here we'll increase the amount of reverberation in this natural soundfield recording. As the image is warped at the same time, we'll also hear the frontal stage widen.
<p>If you haven't already choose a <code>~decoder</code> and defined <code>~renderDecode</code>, do so <a href="#Choose%20a%20decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type transformer, see <a href="./../Classes/FoaXformerMatrix.html#*newDominateX">FoaXformerMatrix: *newDominateX</a> for further details.</div><textarea class='editor'>// ------------------------------------------------------------
// dominateX xformer
// b-format soundfile read from disk


// define xformer matrix
~xformer = FoaXformerMatrix.newDominateX           // no dominance --&gt; try this 1st
~xformer = FoaXformerMatrix.newDominateX(-3.0)    // increase gain at rear


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels.raddeg


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/b-format/Leonard-Orfeo_Trio.wav")


(
{
    var sig;                            // audio signal

    // display xformer &amp; decoder
    "Ambisonic transforming via % xformer".format(~xformer.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, BufRateScale.kr(~sndbuf), doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // transform
    sig = FoaXform.ar(sig, ~xformer);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>J. Leonard, "The Orfeo Trio &amp; TetraMic," Sound of Space: ambisonic surround sound. [Online]. Available: <a href="http://soundofspace.com/ambisonic_files/41">http://soundofspace.com/ambisonic_files/41</a> [Accessed: 03-Nov-2011].</ul>
</div><h2><a class='anchor' name='Transform%20utilities'>Transform utilities</a></h2>

<p>The ATK includes the following useful transform audition and visualization utilities:<dl>
<dt><a href="./../Classes/FoaAudition.html">FoaAudition</a><dd>Audition FOA recordings, panning planewaves, diffuse soundfields, and transforms<dt><a href="./../Classes/FoaXformDisplay.html">FoaXformDisplay</a><dd>Visualize, audition and customize FOA soundfield transforms</dl>

<p>These tools offer a very quick and convenient way to become familiar with the ATK's imaging tranforms. You might like to start with the visualizer, <a href="./../Classes/FoaXformDisplay.html">FoaXformDisplay</a>, as a quick way to understand transformer parameters change a soundfield.<div class='footnotes'>
<a class='anchor' name='footnote_1'/><div class='footnote'>[<a href='#footnote_org_1'>1</a>] - It is also useful to note that the <a href="./../Classes/FoaTransform.html">dynamic</a> transforms are also available as individual UGens. However, users are advised to use <a href="./../Classes/FoaTransform.html">FoaTransform</a> for convenience.</div></div><div class='doclink'>helpfile source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/atk-sc3/HelpSource/Guides/Transforming-FOA.schelp'>/home/stefan/.local/share/SuperCollider/downloaded-quarks/atk-sc3/HelpSource/Guides/Transforming-FOA.schelp</a><br>link::Guides/Transforming-FOA::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>