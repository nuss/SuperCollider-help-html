<!doctype html><html lang='en'><head><title>Introduction to miSCellaneous | SuperCollider 3.12.2 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'Introduction to miSCellaneous';
var scdoc_sc_version = '3.12.2';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>Introduction to miSCellaneous:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#History'>History</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Groups%20of%20content'>Groups of content</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Tour%201:%20VarGui'>Tour 1: VarGui</a></li>
<ul class='toc'><li class='toc2'><a href='#Tour%201a:%20synth%20control'>Tour 1a: synth control</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%201b:%20environmental%20variables%20and%20pattern%20control'>Tour 1b: environmental variables and pattern control</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Tour%202:%20PLx%20suite'>Tour 2: PLx suite</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Tour%203:%20PLx%20patterns%20used%20with%20VarGui'>Tour 3: PLx patterns used with VarGui</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Tour%204:%20PbindFx'>Tour 4: PbindFx</a></li>
<ul class='toc'><li class='toc2'><a href='#Ex.%204a:%20sequencing%20fx%20params%20by%20using%20different%20fx%20buses'>Ex. 4a: sequencing fx params by using different fx buses</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.%204b:%20sequencing%20fx%20params%20by%20using%20PbindFx'>Ex. 4b: sequencing fx params by using PbindFx</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ex.%204c:%20alternation%20of%20fx%20/%20non-fx%20by%20defining%20a%20fxOrder%20sequence'>Ex. 4c: alternation of fx / non-fx by defining a fxOrder sequence</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204d:%20principles%20of%20operation'>Tour 4d: principles of operation</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204e:%20sequential%20application%20of%20fxs%20(fixed%20fx%20chains)'>Tour 4e: sequential application of fxs (fixed fx chains)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204f:%20sequencing%20different%20fx%20chains'>Tour 4f: sequencing different fx chains</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204g:%20parallel%20effects%20and%20arbitrary%20effect%20graphs'>Tour 4g: parallel effects and arbitrary effect graphs</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204h:%20implicit%20parallelism%20of%20single%20effects'>Tour 4h: implicit parallelism of single effects</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204i:%20different%20effects%20with%20parallel%20PbindFxs'>Tour 4i: different effects with parallel PbindFxs</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204j:%20PbindFx%20and%20replacements'>Tour 4j: PbindFx and replacements</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204k:%20continuative%20topics'>Tour 4k: continuative topics</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%204l:%20kitchen%20studies,%20a%20granular%20synthesis%20application'>Tour 4l: kitchen studies, a granular synthesis application</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Tour%205:%20EventShortcuts:%20less%20typing%20with%20Events%20and%20event%20patterns'>Tour 5: EventShortcuts: less typing with Events and event patterns</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Tour%206:%20live%20coding'>Tour 6: live coding</a></li>
<ul class='toc'><li class='toc2'><a href='#Tour%206a:%20PLbindef%20and%20PLbindefPar'>Tour 6a: PLbindef and PLbindefPar</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%206b:%20PLx%20and%20live%20coding%20with%20Strings'>Tour 6b: PLx and live coding with Strings</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Tour%207:%20Independant%20classes,%20class%20families%20and%20methods'>Tour 7: Independant classes, class families and methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Tour%207a:%20PSx%20stream%20patterns'>Tour 7a: PSx stream patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207b:%20PSVx%20sieve%20patterns%20and%20Sieves'>Tour 7b: PSVx sieve patterns and Sieves</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207c:%20PmonoPar%20and%20PpolyPar'>Tour 7c: PmonoPar and PpolyPar</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207d:%20enum'>Tour 7d: enum</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207e:%20HS%20/%20HSpar%20/%20PHS%20/%20PHSpar'>Tour 7e: HS / HSpar / PHS / PHSpar</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207f:%20PSPdiv'>Tour 7f: PSPdiv</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207g:%20Smooth%20Clipping%20and%20Folding'>Tour 7g: Smooth Clipping and Folding</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207h:%20DX%20suite'>Tour 7h: DX suite</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207i:%20Idev%20suite'>Tour 7i: Idev suite</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%207j:%20Nonlinear%20dynamics'>Tour 7j: Nonlinear dynamics</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Tour%208:%20(Rather)%20independant%20SC%20tutorials'>Tour 8: (Rather) independant SC tutorials</a></li>
<ul class='toc'><li class='toc2'><a href='#Tour%208a:%20Event%20patterns%20and%20Functions'>Tour 8a: Event patterns and Functions</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%208b:%20Event%20patterns%20and%20LFOs'>Tour 8b: Event patterns and LFOs</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Tour%208c:%20Event%20patterns%20and%20array%20args'>Tour 8c: Event patterns and array args</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Tour%209:%20Buffer%20Granulation%20and%20Live%20Granulation%20–%20tutorials'>Tour 9: Buffer Granulation and Live Granulation – tutorials</a></li>
<ul class='toc'></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Guides (extension)</span>
 | <span id='categories'><a href='./../Browse.html#Libraries'>Libraries</a>&#8201;&gt;&#8201;<a href='./../Browse.html#Libraries>miSCellaneous'>miSCellaneous</a> | <a href='./../Browse.html#Guides'>Guides</a></span>
</div><h1>Introduction to miSCellaneous<div class='extension-indicator-ctr' title='This help file originates from a third-party quark or plugin for SuperCollider.'><img class='extension-indicator-icon' alt='Extension' src='./../images/plugin.png'><span class='extension-indicator-text'>Extension</span></div></h1>
<div id='summary'>overview, references and examples</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Overviews/miSCellaneous.html">miSCellaneous</a></div>
</div>
<h2><a class='anchor' name='description'>Description</a></h2>

<p>At the beginning of 2017, it was almost 10 years ago when I did my first steps in systematically ordering and extending personal SC tools. At that time I already had some experience in SC, but project-oriented composition was my main focus. Meanwhile miSCellaneous lib has grown and when I look at its readme file, although I always tried to keep stuff documented properly, I doubt that the connections between the different classes would be easy to get at a first glance. Topics accumulated, some help files have become huge (VarGui, PbindFx) and a lot of examples and documented (extra-)features might hide the basic motivations. As I was asked by colleagues at the Institute of Electronic Music and Acoustic Graz (IEM) we organized a one-day lecture/workshop on miSCellaneous lib on November 5th, 2016, and this tutorial summarizes the overview given then. At that point I'd like to say that I'm very grateful to IEM Graz and the interested SC community from here and abroad for support and feedback, we are going to have further SC meetings at the same place – Hanns Holger Rutz already continued in December. There's also a focus on artistic research here at IEM, and research projects, events and discussions are lighting an ongoing discourse in the field between art and science, creating an inspiring environment.
<p>Concerning the structure of this file: after a brief history and a grouping of content the tour will guide through selected topics in an order which, hopefully, will outline the central ideas. It will start with VarGui, PLx, then go over PbindFx, EventShortcuts to live coding aspects of PLx, continue with independant classes, class families, methods and SC tutorials and end with the Buffer Granulation tutorial, which again integrates some of the previous topics. PbindFx gets more space, as it's in my recent focus and you can use it for a number of things which are not, or at least not easily doable in plain SC. To a large extent the tour consists of references to selected already existing examples, which are spread over various help files. Conitinuative, but less central topics are marked as such, as well as some legacy code, which is still working, but not very relevant, as other possibilities have been invented meanwhile. A few new examples have been added, the reader is invited to check the exercises and to have fun with his/her favourite instrument resp. effect SynthDefs. <h2><a class='anchor' name='History'>History</a></h2>

<p>In 2007 / 08 I was working at ZKM Karlsruhe, preparing a piece for flute and multichannel electronics (<em>Lokale Orbits / Solo 3</em>). Then I thought it would be useful to order and document my tools, by doing so my programming would – hopefully – not only be useful for me but for others too and I would be able to give something back to the open source community, from which I have been getting so much valuable input. Also I noticed that a better structuring of code together with the need of documentation stimulated reflection and development and significantly improved the functionality of my tools also just for personal use.
<p><em>Lokale Orbits</em> is a series of works for small instrumentations and multichannel tape where recordings with involved musicians were the base for granular processings. From the beginning miSCellaneous lib was developed in parallel to the needs that came from that artistic motivation. The first particular motivation was related to the fundamental architecture of SC – the division between language and server – and its consequences for granular synthesis. I never wanted to spend much time in gui programming, but I wanted to have a multi-purpose gui that would easily let me experiment with granular synthesis driven by language (patterns in particular) and server (granulation ugens). It should also be easy to combine these different controls in a single patch, e.g. fine-tune the parameters of a LFO and those of a Pattern resp. the derived running EventStreamPlayer at the same time. This need led to the development of the VarGui interface. It is the the oldest part and, so to speak, the kernel of miSCellaneous, already contained in the first public release of 2009. A player section and a number of features was added in 2011. Thus VarGui doesn't use SC's extended gui features which came up with the invention of Qt and if I had to build something from scratch I'd certainly look for a revised code structure, nevertheless VarGui reliably served my needs quite well over a long period of time. The twofold control option (environmental variables and synth args) turned out to be useful in many contexts, also the handling of arrays (environmental variables as well as synth args) is quite practical and allows a quick instantiation of huge slider+player guis.
<p>Between 2009 and 2016 a number of pattern families was added, some of them with granular synthesis in mind. The one I'm using most is the PLx proxy pattern family which takes advantage of environmental variables and dynamic scoping and goes well together with the VarGui interface concerning control of running Patterns/EventStreamPlayers. PLx also opens nice opportunities for live-coding with very condensed syntax. I'm not doing this on stage but I see live-coding as valuable part of a dynamic compositional process. As a side remark, PLx patterns mirror most of SC's main lib patterns and can also be used as non-proxies. In contrast to main lib's list patterns they default to repeats = inf, which probably saved myself the typing of many thousands of 'infs' over the years.
<p>Another part of miSCellaneous is a number of tutorials, which I added from time to time. Some refer to general SC topics, independant from miSCellaneous (e.g. Event patterns and array args), others to topics specific to miSCellaneous (e.g. PLx and live coding with Strings) and in some I tried a general overview of principal SC strategies, but also used examples with features of miSCellaneous (Buffer Granulation). Finally there's other stuff that doesn't fall into the above categories, e.g. the class EventShortcuts for customized shortcuts with Events and event patterns. Classes related to nonlinear dynamics (single sample feedback with Fb1, generailzed functional iteration synthesis with GFIS) have been added in 2018, Fb1_ODE and related, a framework for general ordinary differential equation integration of initial value problems in 2019.<h2><a class='anchor' name='Groups%20of%20content'>Groups of content</a></h2>
<ul>
<li>VarGui (2009), multi-purpose slider / player gui. Can have sliders for control of synth parameters and environmental variables as well as a player section for control of Synths, Tasks or EventStreamPlayers derived from Patterns.<li>Pattern classes/class families:<ul>
<li>PHSx (2009): pattern-like objects using synth values in language, still working but a bit outdated as we have synchronous buses now<li>PLx (2012): dynamic scope proxy patterns, especially suited for VarGui control, also live coding<li>PSx (2014): patterns acting like streams and remembering last values, good for certain types of nested pattern use and recursion<li>PmonoPar, PpolyPar (2015): differently timed setting of event streams<li>PbindFx (2015): sequencing arbitrary effects and effect graphs<li>PLbindef, PLbindefPar (2016): proxies based on Pbindef allowing shortcut replacement syntax<li>PSVx (2016): a pattern implementation of Xenakis sieves related to the class Sieve, Psieve patterns enable an unusual "realtime sieve modification". Interesting for many applications, e.g. granular rhythms, though I didn't have the time to experiment a lot yet.<li>PSPdiv (2017): a dynamic multi-layer pulse divider based on Pspawner<li>Other pattern classes</ul>
<li>Tutorials:<ul>
<li>Event patterns and Functions (2011)<li>Event patterns and LFOs (2011)<li>Buffer Granulation Tutorial (2012): different strategies of buffer granulation and control<li>Event patterns and array args (2015)<li>PLx and live coding with Strings (2016)<li>Sieves and Psieve patterns (2016)<li>kitchen studies (2016): commented source code of six short pieces from a kitchen sound using PbindFx<li>Live Granulation Tutorial (2017): different strategies of live granulation and control<li>Other tutorials</ul>
<li>Other topics:<ul>
<li>enum (2013): general enumeration tool<li>EventShortcuts (2014): user-defined keywords for events and event patterns<li>Smooth Clipping and Folding (2017)<li>DX suite (2017): pseudo ugens for crossfaded mixing and fanning with drate control<li>Idev suite (2018): patterns and drate ugen searching for numbers with integer distance from a source pattern / signal<li>Fb1, GFIS (2018): single sample feedback and generalized functional iteration synthesis<li>Fb1_ODE (2019): general ordinary differential equation integration<li>Other</ul>
</ul>
<h2><a class='anchor' name='Tour%201:%20VarGui'>Tour 1: VarGui</a></h2>

<p>The <a href="./../Classes/VarGui.html">VarGui</a> class help file as well <a href="./../Tutorials/VarGui_shortcut_builds.html">VarGui shortcut builds</a> are both bloated with information, so I'd like to give just a few examples and references here in order to show its basic features.<textarea class='editor'>(
s = Server.local;
Server.default = s;
s.boot;
)</textarea>
<h3><a class='anchor' name='Tour%201a:%20synth%20control'>Tour 1a: synth control</a></h3>
<textarea class='editor'>// quick control of default synth, specs are globally known
// note that amp is set to 0 by its default spec
// start by pressing the green button

VarGui(synth: \default).gui


// alternative (shortcut build) writing

\default.sVarGui.gui</textarea>

<p>For basic control of a self-defined Synth/SynthDef by passing control specs see <a href="./../Classes/VarGui.html#synth_0">this example</a> in VarGui help.
<p>For control of multiple Synths/SynthDefs see <a href="./../Classes/VarGui.html#gt_0">this example</a> in the same file below.
<p>It's often more practical to pass control specs as SynthDef metadata as done in <a href="./../Tutorials/Buffer_Granulation.html#1">Ex.1a</a> of the Buffer Granulation tutorial.<table>
<tr><td><strong>Exercise</strong>: Control your own (sustained) SynthDef with VarGui, either use SynthDef metadata or VarGui's argument 'synthCtr' for passing specs.</table>
<h3><a class='anchor' name='Tour%201b:%20environmental%20variables%20and%20pattern%20control'>Tour 1b: environmental variables and pattern control</a></h3>

<p>For basic control of an environmental variable in combination with a Pbind run <a href="./../Classes/VarGui.html#gt_1">this example</a> in VarGui help.<textarea class='editor'>// after having evaluated p, consider the subtle differences of these variants:
// play with slider values and start and pause ad libitum.
// The quant argument ensures synchronization when starting players separately.

// one array variable in one environment, one player
v = VarGui([\midi, [50, 70, \lin, 1, 55] ! 3], stream: p, quant: 0.2).gui;

// three single variables in three environments, three players
v = VarGui([\midi, [50, 70, \lin, 1, 55]] ! 3, stream: p!3, quant: 0.2).gui;

// three array variables in three environments, three players
v = VarGui([\midi, [50, 70, \lin, 1, 55] ! 3] ! 3, stream: p!3, quant: 0.2).gui;</textarea>

<p>These examples show the application of dynamic scoping. A Function has been defined with an "unconnected" free variable and the players evaluate the Function in different Environments provided by the VarGui. Setting the sliders affects the variable of the same name in different Environments of different players.
<p>This example used a Pfunc, but it works the same with PLx patterns, we take a look at them and leave VarGui for a moment.<h2><a class='anchor' name='Tour%202:%20PLx%20suite'>Tour 2: PLx suite</a></h2>

<p>Pdef and Pdefn are main lib's proxies for replacement of event patterns and non-event patterns. PL is the most general PLx proxy, taking over some combined functionality of Pdef and Pdefn on the base of dynamic scoping, go through the examples of the help file <a href="./../Classes/PL.html">PL</a> to see how it works with value and event patterns. 
<p>Though what neither PL nor Pdef/Pdefn can provide is the replacement of pure lists or list items in the case of list patterns. There's a main lib workaround with a combination of Pn and Plazy (<a href="./../Tutorials/PLx_suite.html#Ex.%201a">PLx suite, Ex.1a</a>), but it isn't satisfying for several reasons, so I suppose that PLx list patterns like PLseq are amongst the most useful ones of the whole PLx family, e.g. see <a href="./../Tutorials/PLx_suite.html#Ex.%201b">PLx suite, Ex.1b</a>. Other PLx list patterns like PLrand, PLwrand, PLser, PLshuf, PLshufn, PLswitch etc. work similar.
<p>There exists also a number of non-list PLx patterns, have a look at <a href="./../Classes/PLwhite.html">PLwhite</a> as a typical example.<table>
<tr><td><strong>Exercise</strong>: Play your own enveloped SynthDef (or take default SynthDef with params: freq, amp, pan) with some PLx patterns and perform live replacements as in the examples above.</table>
<h2><a class='anchor' name='Tour%203:%20PLx%20patterns%20used%20with%20VarGui'>Tour 3: PLx patterns used with VarGui</a></h2>

<p>See <a href="./../Classes/VarGui.html#Ex.%201a">VarGui, Ex.1a</a>, for basic step sequencing with PLseq, the array variable is implicitely defined in VarGui's first arg.
<p>See <a href="./../Classes/VarGui.html#Ex.%201c">VarGui, Ex.1c</a>, for multiple players and array variables and control of multiple sliders and buttons with modifier keys (note that not all functionality might be available on all platforms).
<p>See <a href="./../Classes/VarGui.html#Ex.%204a">VarGui, Ex.4a</a>, for a sequencing setup with some PLs used. But more interesting here is that each synth reads is base frequency from a control bus, which gets its data from a separate synth. Synth and EventStreamPlayer are both controlled from the gui. The two slider blocks on the left side concern Synth settings (above) and variable setting for the Pbind / EventStreamPlayer (below). Accordingly we have two players on the right side. Try running the player and starting and stopping the control synth.
<p><a href="./../Tutorials/Buffer_Granulation.html#2">Buffer Granulation, Ex.2a</a>, shows basic language-driven granulation, gui values are taken over by PL patterns and Pfunc.<table>
<tr><td><strong>Exercise</strong>: Write a combination of an event pattern and PLx patterns as above with your own SynthDef and play it with a VarGui. Note that it's not necessary to control all args by the gui, nor is it necessary to control parameters directly: you can e.g. control bounds for midinotes in the gui and define the calculation for the actual midinote (e.g. random selection) in the event pattern:<textarea class='editor'>\midinote, PLwhite(\midiLo, \midiHi),</textarea>
</table>
<h2><a class='anchor' name='Tour%204:%20PbindFx'>Tour 4: PbindFx</a></h2>

<p>PbindFx is an event pattern for effect handling on per-event base. There are other ways for working with event patterns and effects, already possible with main lib, but they have disadvantages: with Pfx and Pfxb there is no built-in way to sequence effect types or effect parameters, you could also route the event's audio to effect buses, but for overlapping events with different fx graphs/params you'd have to define additional buses beforehand as in Ex. 4a.<h3><a class='anchor' name='Ex.%204a:%20sequencing%20fx%20params%20by%20using%20different%20fx%20buses'>Ex. 4a: sequencing fx params by using different fx buses</a></h3>

<p>First go to <a href="./../Classes/PbindFx.html#Ex.%201a">PbindFx, Ex. 1a</a>, reboot server with extended ressources and evaluate source and fx synths.<textarea class='editor'>// start fxs 
(
a = Bus.audio(s, 2);
b = Bus.audio(s, 2);

x = Synth(\echo, [decayTime: 1.5, echoDelta: 0.15, in: a]);
y = Synth(\echo, [decayTime: 5, echoDelta: 0.1, in: b]);
)

// play pattern, the two effects allow switching between them
(
p = Pbind(
    \dur, 0.5,
    \instrument, \source,
    \note, Pshuf((0..11), inf) + Pseq([[0.2, 14.2], [0, 4], [0, 4]], inf),
    \octave, Pwhite(3, 6),
    \out, Pseq([b, a, a], inf)  // here we do fx sequencing
).play
)

p.stop

// we need to do cleanup manually here

[x, y, a, b].do(_.free);</textarea>
<h3><a class='anchor' name='Ex.%204b:%20sequencing%20fx%20params%20by%20using%20PbindFx'>Ex. 4b: sequencing fx params by using PbindFx</a></h3>
<textarea class='editor'>// Ex. 4a translated to PbindFx syntax –
// though it's not exactly identical as fxs are processed in not only two but
// more parallel fx synths

(
p = PbindFx([
        \dur, 0.5,
        \instrument, \source,
        \note, PLshuf((0..11)) + PLseq([[0.2, 14.2], [0, 4], [0, 4]]),
        \octave, Pwhite(3, 6),
        \fxOrder, 1    // always fx #1 (echo)
    ],[
        \fx, \echo,
        \decayTime, PLseq([5, 1.5, 1.5]),
        \echoDelta, PLseq([0.1, 0.15, 0.15]),
        \cleanupDelay, 5.2,    // with short default echo would be cut

        // this would save a bit CPU
        // \cleanupDelay, PLseq([5, 1.5, 1.5]) + 0.2
    ]
).play
)


// cleanup (delayed freeing of synths and buses) is done automatically
// watch server window:

p.stop


// now run the same example with the following variant of 'echoDelta',
// obviously the result cannot be achieved with an approach like in Ex. 4a

        \echoDelta, Pwhite(0.05, 0.2)</textarea>
<h3><a class='anchor' name='Ex.%204c:%20alternation%20of%20fx%20/%20non-fx%20by%20defining%20a%20fxOrder%20sequence'>Ex. 4c: alternation of fx / non-fx by defining a fxOrder sequence</a></h3>
<textarea class='editor'>(
p = PbindFx([
        \dur, 0.2,
        \instrument, \source,
        \note, PLshuf((0..11)) + PLseq([[0.4, 14.4], [0, 4], [0, 4]]),
        \octave, Pwhite(3, 6),

        // fxOrder = 0 means no fx
        \fxOrder,  PLseq([0, 0, 1]),

        // if no fx, we need to compensate the unified echo delay of 0.2
        \lag, Pif(Pkey(\fxOrder) &gt; 0, 0, 0.2)
    ],[
        \fx, \echo,
        \decayTime, PLseq([5, 1.5, 1.5]),
        \echoDelta, Pwhite(0.04, 0.12),
        \cleanupDelay, PLseq([5, 1.5, 1.5]) + 0.2
    ]
).play
)

p.stop</textarea>
<table>
<tr><td><strong>Exercise</strong>: Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of no fx and echos (by defining 'fxOrder') and echo params as in Ex. 4c. Note that in fx 'echo' the max echoDelta defaults to 0.2.</table>
<h3><a class='anchor' name='Tour%204d:%20principles%20of%20operation'>Tour 4d: principles of operation</a></h3>

<p>For each event several issues have to be internally considered by PbindFx: building and checking of fx graphs (no cycles !), cleaning buses from possibly remaining residual audio (adding "zero synths"), splitting (in case of parallel parts in the fx graph), grouping of all event-related synths and checking accumulated cleanup delay times. You might skip that for the moment, but for a more detailled overview see <a href="./../Classes/PbindFx.html#Principle%20of%20operation">Principle of operation</a>, as well as for a listing of conventions.<h3><a class='anchor' name='Tour%204e:%20sequential%20application%20of%20fxs%20(fixed%20fx%20chains)'>Tour 4e: sequential application of fxs (fixed fx chains)</a></h3>

<p>See PbindFx, examples <a href="./../Classes/PbindFx.html#Ex.%201a">1a</a> and <a href="./../Classes/PbindFx.html#Ex.%201b">1b</a>.<h3><a class='anchor' name='Tour%204f:%20sequencing%20different%20fx%20chains'>Tour 4f: sequencing different fx chains</a></h3>

<p>See PbindFx, examples <a href="./../Classes/PbindFx.html#Ex.%202a">2a</a>, <a href="./../Classes/PbindFx.html#Ex.%202b">2b</a>, <a href="./../Classes/PbindFx.html#Ex.%202c">2c</a>, <a href="./../Classes/PbindFx.html#Ex.%202d">2d</a>.<table>
<tr><td><strong>Exercise</strong>: Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of fx chains (your fxs and/or fxs from PbindFx help). Maybe just extend your last own example.</table>
<h3><a class='anchor' name='Tour%204g:%20parallel%20effects%20and%20arbitrary%20effect%20graphs'>Tour 4g: parallel effects and arbitrary effect graphs</a></h3>

<p>It seems to be a still underestimated option to design effect graphs different from simple chains. In a classical DAW interface a pile of slots for effects in chain is common, although more differentiated possibilities are also there. Considering event sequencing with PbindFx we can select fx graphs per event / grain, in addition to the sequencing of fx parameters itself. See <a href="./../Classes/PbindFx.html#Ex.%2010a">PbindFx, Ex.10a</a>, for a parallel application of echo, note the syntax of the event graph, passed as Event to 'fxOrder'.<table>
<tr><td><strong>Exercise</strong>: Compare the sound of the two fx graphs given in <a href="./../Classes/PbindFx.html#Ex.%2010a">Ex.10a</a>, also try the following or similar, how do the corresponding fx graphs look like ?<textarea class='editor'>    \fxOrder, `(0: 1, 1: [2, 3], 2: 4),
    
    \fxOrder, `(0: 1, 1: [2, 3, \o], 2: 4),

    \fxOrder, `(0: 1, 1: [2, 3], 3: 4, 2: 3),
    
    \fxOrder, `(0: 1, 1: [2, 3], 3: 2, 2: 4),

    \fxOrder, `(0: 1, 1: [2, 3, \o], 3: 4, 2: 3),</textarea>
</table>

<p>See PbindFx, Ex. <a href="./../Classes/PbindFx.html#Ex.%2010b">10b</a> and <a href="./../Classes/PbindFx.html#Ex.%2010c">10c</a> for modulation graphs and their sequencing.<table>
<tr><td><strong>Exercise</strong>: Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of fx *graphs* (your fxs and/or fxs from PbindFx help). Maybe just extend your last own example.</table>
<h3><a class='anchor' name='Tour%204h:%20implicit%20parallelism%20of%20single%20effects'>Tour 4h: implicit parallelism of single effects</a></h3>

<p>This can simple be done by passing arrays within fxData, see <a href="./../Classes/PbindFx.html#Ex.%204">PbindFx, Ex.4a</a>. <h3><a class='anchor' name='Tour%204i:%20different%20effects%20with%20parallel%20PbindFxs'>Tour 4i: different effects with parallel PbindFxs</a></h3>

<p>A further option for parallelism, a typical case would be the application of different effects to the notes of a chord, see <a href="./../Classes/PbindFx.html#Ex.%203b">PbindFx, Ex.3b</a> (rather straight than 3a). <h3><a class='anchor' name='Tour%204j:%20PbindFx%20and%20replacements'>Tour 4j: PbindFx and replacements</a></h3>

<p>See <a href="./../Classes/PbindFx.html#Ex.%207a">PbindFx, Ex.7a</a> for replacement of key streams.
<p>Up to now PbindFx got lists as args in all examples. As args can be event patterns too, they can also be proxy patterns which opens the door for various unusual kinds of source and fx replacements, see PbindFx Ex. <a href="./../Classes/PbindFx.html#Ex.%207b">7b</a> and <a href="./../Classes/PbindFx.html#Ex.%207c">7c</a>.<table>
<tr><td><strong>Exercise</strong>: Take one of your previous working PbindFx examples and rewrite its args (arrays of key/value pairs) as PL or Pbindef proxies. Run the example and replace source and/or fx patterns on the fly.</table>
<h3><a class='anchor' name='Tour%204k:%20continuative%20topics'>Tour 4k: continuative topics</a></h3>

<p>For use with VarGui see <a href="./../Classes/PbindFx.html#Ex.%208">PbindFx, Ex.8</a>.
<p>For using one fx SynthDef in more than one fxData see <a href="./../Classes/PbindFx.html#Ex.%204">PbindFx, Ex.4</a>.
<p>For source and fxs reading from external buses (ar or kr) see <a href="./../Classes/PbindFx.html#Ex.%206a">PbindFx, Ex.6a-c</a>.
<p>For using value conversions with fxData see PbindFx, <a href="./../Classes/PbindFx.html#Ex.%209">PbindFx, Ex.9</a>.<h3><a class='anchor' name='Tour%204l:%20kitchen%20studies,%20a%20granular%20synthesis%20application'>Tour 4l: kitchen studies, a granular synthesis application</a></h3>

<p>One motivation for the development of PbindFx was the idea to explore granular synthesis variants with differentiated effect processings. The fixed media composition <em>kitchen studies</em> collects six short pieces with different fxs and handlings of fx sequencing, each derived from the kitchen sound of five seconds, which is already contained in miSCellaneous lib. At the same time <em>kitchen studies</em> is an ongoing artistic research project: the commented source code is published in the tutorial <a href="./../Tutorials/kitchen_studies.html">kitchen studies</a>, compressed versions of the original piece as a whole and its parts can be found on my website <a href="http://daniel-mayer.at">http://daniel-mayer.at</a> (use a separate browser, players won't work within this window), a further documentation of the compositional process will follow as publication in the artistic research database <em>Research Catalogue</em> (<a href="http://researchcatalogue.net">http://researchcatalogue.net</a>).<h2><a class='anchor' name='Tour%205:%20EventShortcuts:%20less%20typing%20with%20Events%20and%20event%20patterns'>Tour 5: EventShortcuts: less typing with Events and event patterns</a></h2>

<p>EventShortcuts is an interface for defining your own shortcut keys for often used keyword in Events and event patterns. For example you might want to write 'inst' or just 'i' instead of 'instrument' etc., then define your collection of shortcuts – e.g. in your startup or a certain load file – and activate it on occasion. There is also a default shortcuts dictionary, see its content and play a simple example:<textarea class='editor'>EventShortcuts.on;

EventShortcuts.postAll;

x = Pbind(\m, Pwhite(60, 90), \d, 0.2).play;</textarea>

<p>For examples of (re-)defining or extending shortcut dictionaries see <a href="./../Classes/EventShortcuts.html">EventShortcuts</a>.<table>
<tr><td><strong>Exercise</strong>: Take one of your favourite SynthDefs with non-standard arguments (other than freq, amp, pan, etc.) and write an event pattern example, using these arguments. Then choose useful abbreviations, define a new shortcut dictionary with these (either by extending the default or by defining a new one), make it current and run the event pattern example with abbreviated keys.</table>
<h2><a class='anchor' name='Tour%206:%20live%20coding'>Tour 6: live coding</a></h2>

<p>This was not my main focus from the beginning, but it turned out that PLx patterns, in combination with EventShortcuts and/or Character sequencing (tour 6b) open up live coding possibilities with very condensed syntax.<h3><a class='anchor' name='Tour%206a:%20PLbindef%20and%20PLbindefPar'>Tour 6a: PLbindef and PLbindefPar</a></h3>

<p>PLbindef is a wrapper class for Pbindef, which allows replacements in pseudo-method syntax in a newly created Environment.<textarea class='editor'>EventShortcuts.on;

PLbindef(\x, \d, 0.2, \m, Pwhite(60, 90)).play;

// Now 'x' is also the name of a new PLbindefEnvironment in the current Environment,
// its pseudo-methods can be used for setting, moreover it is a player also.

~x.play

~x.m = PLseq((60..70))

~x.stop</textarea>

<p>For further examples see <a href="./../Classes/PLbindef.html">PLbindef</a>.
<p>PLbindefPar is also based on Pbindef, but unlike PLbindef it's not a plain wrapper: it employs a number of Pbindefs in parallel, which allows control of polyphonic, additive or granular structures, see <a href="./../Classes/PLbindefPar.html">PLbindefPar</a>. <div class='warning'><span class='warninglabel'>WARNING:</span> If you're piling up a lot of layers, be careful with amplitudes, the amplitude values are taken for the single layers, so you'd have to reduce them accordingly !</div><h3><a class='anchor' name='Tour%206b:%20PLx%20and%20live%20coding%20with%20Strings'>Tour 6b: PLx and live coding with Strings</a></h3>

<p>Already in plain SC Strings as Arrays of Characters can be used for sequencing. PLx patterns fit and continuate this concept, see <a href="./../Tutorials/PLx_and_live_coding_with_Strings.html">PLx and live coding with Strings</a> for some options, also in connection with PLbindef, PLbindefPar and PbindFx.<h2><a class='anchor' name='Tour%207:%20Independant%20classes,%20class%20families%20and%20methods'>Tour 7: Independant classes, class families and methods</a></h2>
<h3><a class='anchor' name='Tour%207a:%20PSx%20stream%20patterns'>Tour 7a: PSx stream patterns</a></h3>

<p>These are a bit paradoxical classes: Patterns which behave as if they were Streams, thus have an internal state and remember its last value(s), which can e.g. be used for recursion or certain demands of repeated embedding as in the following example:<textarea class='editor'>(
// PS gets source and length patterns as args

p = PLseq([
    PS(PLseq((1..5)), PLseq([1, 2])),
    PS(PLseq((1..5) * 100), PLrand((3..5)))
]);

p.asStream.nextN(100)
)

// this can also be written with a combination of Streams and Patterns,
// but it needs more typing (same with Pswitch1 variants)

(
a = Pseq((1..5), inf).asStream;
b = Pseq((1..5) * 100, inf).asStream;

p = Pseq([
    Pfuncn({ a.next }, Pseq([1, 2], inf).asStream), 
    Pfuncn({ b.next }, Prand((3..5), inf).asStream),
], inf);

p.asStream.nextN(100)
)</textarea>

<p>See <a href="./../Tutorials/PSx_stream_patterns.html">PSx stream patterns</a> for an overview.<h3><a class='anchor' name='Tour%207b:%20PSVx%20sieve%20patterns%20and%20Sieves'>Tour 7b: PSVx sieve patterns and Sieves</a></h3>

<p>Sieves, recommended by Iannis Xenakis as generative principles for arbitrary musical parameters, are implemented twice: with the class Sieve and Psieve patterns, which adapt the sieve calculus for realtime interactions. The tutorial <a href="./../Tutorials/Sieves_and_Psieve_patterns.html">Sieves and Psieve patterns</a> starts from scratch, thus can be studied completely independant from other miSCellaneous stuff and most other SC requirements. The last chapter gives some audio examples, granular rhythms might be an especially interesting application.<h3><a class='anchor' name='Tour%207c:%20PmonoPar%20and%20PpolyPar'>Tour 7c: PmonoPar and PpolyPar</a></h3>

<p><a href="./../Classes/PmonoPar.html">PmonoPar</a> follows the Pmono convention of a single synth, being set but extends it to an arbitrary number of differently timed setting streams. With <a href="./../Classes/PpolyPar.html">PpolyPar</a> the number of continously running synths is arbitrary as well and setting streams can switch the synths to set. That way complicated fx variations can be achieved by a paradigm different from <a href="./../Classes/PbindFx.html">PbindFx</a>.<h3><a class='anchor' name='Tour%207d:%20enum'>Tour 7d: enum</a></h3>

<p>A general tool, which can be used for many enumeration and optimization problems (sets, partitions, graphs etc.), melodic shapes and scales are possible musical applications, see <a href="./../Tutorials/enum.html">enum</a>.<h3><a class='anchor' name='Tour%207e:%20HS%20/%20HSpar%20/%20PHS%20/%20PHSpar'>Tour 7e: HS / HSpar / PHS / PHSpar</a></h3>

<p>A framework for using server-generated values in Pbind-like objects in the language. A bit outdated now, as synchronous bus gives easy access to server values, however the double-latency mechanism provides a good accuracy of values – if this is needed – by passing a high granularity parameter. A lower value minimizes OSC traffic if this is more important. See <a href="./../Guides/Guide_to_HS_and_HSpar.html">Guide to HS and HSpar</a>.<h3><a class='anchor' name='Tour%207f:%20PSPdiv'>Tour 7f: PSPdiv</a></h3>

<p>A dynamic multi-layer pulse divider based on Pspawner, as the latter it supports parallel and sequential sprouting of sub-patterns. Might be used for line ornamentation, polyrhythmical structures, granulation etc., see <a href="./../Classes/PSPdiv.html">PSPdiv</a>.<h3><a class='anchor' name='Tour%207g:%20Smooth%20Clipping%20and%20Folding'>Tour 7g: Smooth Clipping and Folding</a></h3>

<p>A suite of pseudo ugens, see <a href="./../Tutorials/Smooth_Clipping_and_Folding.html">Smooth Clipping and Folding</a>.<h3><a class='anchor' name='Tour%207h:%20DX%20suite'>Tour 7h: DX suite</a></h3>

<p>pseudo ugens for crossfaded mixing and fanning according to demand-rate control, see <a href="./../Tutorials/DX_suite.html">DX suite</a>.<h3><a class='anchor' name='Tour%207i:%20Idev%20suite'>Tour 7i: Idev suite</a></h3>

<p>patterns and drate ugen searching for numbers with integer distance from a source pattern / signal, see <a href="./../Tutorials/Idev_suite.html">Idev suite</a>.<h3><a class='anchor' name='Tour%207j:%20Nonlinear%20dynamics'>Tour 7j: Nonlinear dynamics</a></h3>

<p>pseudo ugens for single sample feedback and generalized functional iteration synthesis, see <a href="./../Classes/Fb1.html">Fb1</a> and <a href="./../Classes/GFIS.html">GFIS</a>. General ordinary differential equation integration, see <a href="./../Classes/Fb1_ODE.html">Fb1_ODE</a> and related classes.<h2><a class='anchor' name='Tour%208:%20(Rather)%20independant%20SC%20tutorials'>Tour 8: (Rather) independant SC tutorials</a></h2>
<h3><a class='anchor' name='Tour%208a:%20Event%20patterns%20and%20Functions'>Tour 8a: Event patterns and Functions</a></h3>

<p>This tutorial is about dynamic scope, comparing the behaviour of Functions, Streams and EventStreamPlayers in Environments. It's thus treating some preconditions which are relevant for <a href="./../Tutorials/PLx_suite.html">PLx suite</a> and <a href="./../Classes/VarGui.html">VarGui</a>, see <a href="./../Tutorials/Event_patterns_and_Functions.html">Event patterns and Functions</a>.<h3><a class='anchor' name='Tour%208b:%20Event%20patterns%20and%20LFOs'>Tour 8b: Event patterns and LFOs</a></h3>

<p>Continuous (with LFO) and discrete ("LFO-like") control strategies for event patterns are compared in <a href="./../Tutorials/Event_patterns_and_LFOs.html">Event patterns and LFOs</a>.<h3><a class='anchor' name='Tour%208c:%20Event%20patterns%20and%20array%20args'>Tour 8c: Event patterns and array args</a></h3>

<p>SynthDef array args seem to be a sometimes confusing topic, especially when it's about (pseudo-)variable array lengths and Envelopes, this is even more the case when it comes to the sequencing of such synths. For this reason, and not at last to remind myself to the subtle syntax differences, I wrote this tutorial: <a href="./../Tutorials/Event_patterns_and_array_args.html">Event patterns and array args</a>.<h2><a class='anchor' name='Tour%209:%20Buffer%20Granulation%20and%20Live%20Granulation%20–%20tutorials'>Tour 9: Buffer Granulation and Live Granulation – tutorials</a></h2>

<p>Actually scheduled as a general overview of granulation possibilities in SC, also collecting various ideas from the sc-users mailing list discussions, I have to admit that in its current form many examples, especially in the Buffer granulation tutorial, require one or more features of miSCellaneous and thus might not always be easy to follow. Then again it would be hard to write such (gui) examples without presuppositions and at the same time with a clearly representable amount of code. However I hope that based on this guided tour it might be easier to step through for people who haven't used this lib before, see <a href="./../Tutorials/Buffer_Granulation.html">Buffer Granulation</a> and <a href="./../Tutorials/Live_Granulation.html">Live Granulation</a>.<div class='doclink'>helpfile source: <a href='file:///home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Guides/Introduction_to_miSCellaneous.schelp'>/home/stefan/.local/share/SuperCollider/downloaded-quarks/miSCellaneous_lib/HelpSource/Guides/Introduction_to_miSCellaneous.schelp</a><br>link::Guides/Introduction_to_miSCellaneous::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>